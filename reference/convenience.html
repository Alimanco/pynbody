
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic Convenience Modules &#8212; pynbody 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Automatically Derived Arrays" href="derived.html" />
    <link rel="prev" title="Essential Framework Modules" href="essentials.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

<link href="https://fonts.googleapis.com/css?family=Quicksand" rel="stylesheet">
<link href="_static/customise.css" rel="stylesheet">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38063425-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pynbody.bridge">
<span id="generic-convenience-modules"></span><h1>Generic Convenience Modules<a class="headerlink" href="#module-pynbody.bridge" title="Permalink to this headline">¶</a></h1>
<div class="section" id="bridge">
<h2>bridge<a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h2>
<p>The bridge module has tools for connecting different outputs. For instance,
it’s possible to take a subview (e.g. a halo) from one snapshot and ‘push’
it into the other. This is especially useful if the two snapshots are
different time outputs of the same simulation.</p>
<p>Once connected, bridge called on a specific subset of particles in
output1 will trace these particles back (or forward) to the output2,
enabling observing a change in their properties, such as position,
temperature, etc.</p>
<p>For a tutorial on how to use the bridge module to trace the particles
in your simulation, see the <a class="reference external" href="http://pynbody.github.io/pynbody/tutorials/bridge.html">bridge tutorial</a>.</p>
<dl class="py class">
<dt id="pynbody.bridge.Bridge">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.bridge.</code><code class="sig-name descname">Bridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">end</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#Bridge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.Bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic Bridge class</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(s)</p></td>
<td><p>Given a subview of either the start or end point of the bridge, generate the corresponding subview of the connected snapshot</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.bridge.Bridge.catalog_transfer_matrix" title="pynbody.bridge.Bridge.catalog_transfer_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">catalog_transfer_matrix</span></code></a>([min_index, …])</p></td>
<td><p>Return a max_index x max_index matrix with the number of particles transferred from the row group in groups_1 to the column group in groups_2.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.bridge.Bridge.fuzzy_match_catalog" title="pynbody.bridge.Bridge.fuzzy_match_catalog"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fuzzy_match_catalog</span></code></a>([min_index, max_index, …])</p></td>
<td><p>fuzzy_match_catalog returns, for each halo in groups_1, a list of possible identifications in groups_2, along with the fraction of particles in common between the two.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.bridge.Bridge.is_same" title="pynbody.bridge.Bridge.is_same"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_same</span></code></a>(i2)</p></td>
<td><p>Returns true if the particle i1 in the start point is the same as the particle i2 in the end point.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.bridge.Bridge.match_catalog" title="pynbody.bridge.Bridge.match_catalog"><code class="xref py py-obj docutils literal notranslate"><span class="pre">match_catalog</span></code></a>([min_index, max_index, …])</p></td>
<td><p>Given a Halos object groups_1, a Halos object groups_2 and a Bridge object connecting the two parent simulations, this identifies the most likely ID’s in groups_2 of the objects specified in groups_1.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.bridge.Bridge.is_same">
<code class="sig-name descname">is_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#Bridge.is_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.Bridge.is_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the particle i1 in the start point is the same
as the particle i2 in the end point.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.bridge.Bridge.match_catalog">
<code class="sig-name descname">match_catalog</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_index</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_index</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">groups_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">groups_2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_family</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#Bridge.match_catalog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.Bridge.match_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Halos object groups_1, a Halos object groups_2 and a
Bridge object connecting the two parent simulations, this identifies
the most likely ID’s in groups_2 of the objects specified in groups_1.</p>
<p>If groups_1 and groups_2 are not specified, they are automatically obtained
using the SimSnap.halos method.</p>
<p>Parameters min_index and max_index are the minimum and maximum halo
numbers to be matched (in both ends of the bridge). If max_index is
too large, the catalogue matching can take prohibitively long (it
scales as max_index^2).</p>
<p>This routine currently uses particle number as a proxy for mass, so that the
main simulation data does not need to be loaded.</p>
<p>If b links snapshot f1 (high redshift) to f2 (low redshift) and we set</p>
<blockquote>
<div><p>cat = b.match_catalog()</p>
</div></blockquote>
<p>then cat is now a numpy index array such that f1.halos()[i] is the
major progenitor for f2.halos()[cat[i]], assuming cat[i] is positive.</p>
<p>cat[0:min_index+1] is set to -2. Halos which cannot be matched because
they have too few particles in common give the result -1. This is determined
by the given threshold fraction of particles in common (by default, 50%).</p>
<p>If use_family is specified, only particles from that family are cross-matched.
This can be useful e.g. if matching between two different simulations where
the relationship between DM particles is known, but perhaps the relationship
between star particles is random.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.bridge.Bridge.fuzzy_match_catalog">
<code class="sig-name descname">fuzzy_match_catalog</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_index</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_index</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">groups_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">groups_2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_family</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">only_family</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#Bridge.fuzzy_match_catalog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.Bridge.fuzzy_match_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>fuzzy_match_catalog returns, for each halo in groups_1, a list of possible
identifications in groups_2, along with the fraction of particles in common
between the two.</p>
<p>Normally, match_catalog is simpler to use, but this routine offers greater
flexibility for advanced users. The first entry for each halo corresponds
to the output from match_catalog.</p>
<p>If no identification is found, the entry is the empty list [].</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.bridge.Bridge.catalog_transfer_matrix">
<code class="sig-name descname">catalog_transfer_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_index</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_index</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">groups_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">groups_2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_family</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">only_family</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#Bridge.catalog_transfer_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.Bridge.catalog_transfer_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a max_index x max_index matrix with the number of particles transferred from
the row group in groups_1 to the column group in groups_2.</p>
<p>Normally, match_catalog (or fuzzy_match_catalog) are easier to use, but this routine
provides the maximal information.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.bridge.OrderBridge">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.bridge.</code><code class="sig-name descname">OrderBridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">end</span></em>, <em class="sig-param"><span class="n">order_array</span><span class="o">=</span><span class="default_value">'iord'</span></em>, <em class="sig-param"><span class="n">monotonic</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">allow_family_change</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#OrderBridge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.OrderBridge" title="Permalink to this definition">¶</a></dt>
<dd><p>An OrderBridge uses integer arrays in two simulations
(start,end) where particles i_start and i_end are
defined to be the same if and only if
start[order_array][i_start] == start[order_array][i_end].</p>
<p>If monotonic is True, order_array must be monotonically increasing
in both ends of the bridge (and this is not checked for you). If
monotonic is False, the bridging is slower but this is the
failsafe option.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(s)</p></td>
<td><p>Given a subview of either the start or end point of the bridge, generate the corresponding subview of the connected snapshot</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">catalog_transfer_matrix</span></code>([min_index, …])</p></td>
<td><p>Return a max_index x max_index matrix with the number of particles transferred from the row group in groups_1 to the column group in groups_2.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fuzzy_match_catalog</span></code>([min_index, max_index, …])</p></td>
<td><p>fuzzy_match_catalog returns, for each halo in groups_1, a list of possible identifications in groups_2, along with the fraction of particles in common between the two.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.bridge.OrderBridge.is_same" title="pynbody.bridge.OrderBridge.is_same"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_same</span></code></a>(i1, i2)</p></td>
<td><p>Returns true if the particle i1 in the start point is the same as the particle i2 in the end point.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">match_catalog</span></code>([min_index, max_index, …])</p></td>
<td><p>Given a Halos object groups_1, a Halos object groups_2 and a Bridge object connecting the two parent simulations, this identifies the most likely ID’s in groups_2 of the objects specified in groups_1.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.bridge.OrderBridge.is_same">
<code class="sig-name descname">is_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i1</span></em>, <em class="sig-param"><span class="n">i2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#OrderBridge.is_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.OrderBridge.is_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the particle i1 in the start point is the same
as the particle i2 in the end point.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynbody.bridge.bridge_factory">
<code class="sig-prename descclassname">pynbody.bridge.</code><code class="sig-name descname">bridge_factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/bridge.html#bridge_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.bridge_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bridge connecting the two specified snapshots. For
more information see <span class="xref std std-ref">bridge-tutorial</span>.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.filt"></span><div class="section" id="filt">
<h2>filt<a class="headerlink" href="#filt" title="Permalink to this headline">¶</a></h2>
<p>Defines and implements ‘filters’ which allow abstract subsets
of data to be specified.</p>
<p>See the <a class="reference external" href="http://pynbody.github.io/pynbody/tutorials/filters.html">filter tutorial</a> for some
sample usage.</p>
<dl class="py class">
<dt id="pynbody.filt.Sphere">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">Sphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">cen</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#Sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return particles that are within <cite>radius</cite> of the point <cite>cen</cite>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.filt.Cuboid">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">Cuboid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">y1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">z1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">z2</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#Cuboid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.Cuboid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cube with specified edge coordinates. If any of the cube
coordinates <cite>x1</cite>, <cite>y1</cite>, <cite>z1</cite>, <cite>x2</cite>, <cite>y2</cite>, <cite>z2</cite> are not specified
they are determined as <cite>y1=x1;</cite> <cite>z1=x1;</cite> <cite>x2=-x1;</cite> <cite>y2=-y1;</cite>
<cite>z2=-z1</cite>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.filt.Disc">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">Disc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">height</span></em>, <em class="sig-param"><span class="n">cen</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#Disc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.Disc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return particles that are within a disc of extent <cite>radius</cite> and
thickness <cite>height</cite> centered on <cite>cen</cite>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.filt.BandPass">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">BandPass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prop</span></em>, <em class="sig-param"><span class="n">min</span></em>, <em class="sig-param"><span class="n">max</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#BandPass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.BandPass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return particles whose property <cite>prop</cite> is within <cite>min</cite> and <cite>max</cite>,
which can be specified as unit strings.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.filt.HighPass">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">HighPass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prop</span></em>, <em class="sig-param"><span class="n">min</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#HighPass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.HighPass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return particles whose property <cite>prop</cite> exceeds <cite>min</cite>, which can be
specified as a unit string.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.filt.LowPass">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">LowPass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prop</span></em>, <em class="sig-param"><span class="n">max</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#LowPass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.LowPass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return particles whose property <cite>prop</cite> is less than <cite>max</cite>, which can be
specified as a unit string.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(sim)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>where</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt id="pynbody.filt.Annulus">
<code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">Annulus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r1</span></em>, <em class="sig-param"><span class="n">r2</span></em>, <em class="sig-param"><span class="n">cen</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#Annulus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.Annulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that returns a filter which selects particles
in between two spheres specified by radii <cite>r1</cite> and <cite>r2</cite> centered
on <cite>cen</cite>.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.filt.SolarNeighborhood">
<code class="sig-prename descclassname">pynbody.filt.</code><code class="sig-name descname">SolarNeighborhood</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r1</span><span class="o">=</span><span class="default_value">Unit('5.00e+00 kpc')</span></em>, <em class="sig-param"><span class="n">r2</span><span class="o">=</span><span class="default_value">Unit('1.00e+01 kpc')</span></em>, <em class="sig-param"><span class="n">height</span><span class="o">=</span><span class="default_value">Unit('2.00e+00 kpc')</span></em>, <em class="sig-param"><span class="n">cen</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/filt.html#SolarNeighborhood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.filt.SolarNeighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that returns a filter which selects particles
in a disc between radii <cite>r1</cite> and <cite>r2</cite> and thickness <cite>height</cite>.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.halo"></span><div class="section" id="halo">
<h2>halo<a class="headerlink" href="#halo" title="Permalink to this headline">¶</a></h2>
<p>Implements halo catalogue functions. If you have a supported halo
catalogue on disk or a halo finder installed and correctly configured,
you can access a halo catalogue through f.halos() where f is a
SimSnap.</p>
<p>See the <a class="reference external" href="http://pynbody.github.io/pynbody/tutorials/halos.html">halo tutorial</a> for some
examples.</p>
<dl class="py class">
<dt id="pynbody.halo.Halo">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.halo.</code><code class="sig-name descname">Halo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">halo_id</span></em>, <em class="sig-param"><span class="n">halo_catalogue</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwa</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#Halo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.Halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic class representing a halo.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></dt><dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd>
<dt><strong>filename</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_keys</span></code>()</p></td>
<td><p>Returns a list of all arrays that can be either lazy-evaluated or lazy loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bridge</span></code>(other)</p></td>
<td><p>Tries to construct a bridge function between this SimSnap and another one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conversion_context</span></code>()</p></td>
<td><p>Return a dictionary containing a (scalefactor) and h (Hubble constant in canonical units) for this snapshot, ready for passing into unit conversion functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivable_keys</span></code>()</p></td>
<td><p>Returns a list of arrays which can be lazy-evaluated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derived_quantity</span></code>(fn)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">families</span></code>()</p></td>
<td><p>Return the particle families which have representitives in this SimSnap.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">family_keys</span></code>([fam])</p></td>
<td><p>Return list of arrays which are not accessible from this view, but can be accessed from family-specific sub-views.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(key[, alternative])</p></td>
<td><p>Standard python get method, returns self[key] if key in self else alternative</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_index_list</span></code>(relative_to[, of_particles])</p></td>
<td><p>Get a list specifying the index of the particles in this view relative to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">halos</span></code>(*args, **kwargs)</p></td>
<td><p>Tries to instantiate a halo catalogue object for the given snapshot, using the first available method (as defined in the configuration files).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_family_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory) for at least one family</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_original_units</span></code>(*args)</p></td>
<td><p>Return the units on disk for a quantity with the specified dimensions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersect</span></code>(other[, op])</p></td>
<td><p>Returns the set intersection of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ancestor</span></code>(other)</p></td>
<td><p>Returns true if other is a subview of self</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_derived_array</span></code>(v[, fam])</p></td>
<td><p>Returns True if the array or family array of given name is auto-derived (and therefore read-only).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_descendant</span></code>(other)</p></td>
<td><p>Returns true if self is a subview of other</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.halo.Halo.is_subhalo" title="pynbody.halo.Halo.is_subhalo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_subhalo</span></code></a>(otherhalo)</p></td>
<td><p>Convenience function that calls the corresponding function in a halo catalogue.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p>Returns a list of tuples describing the array names and their contents in memory</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</p></td>
<td><p>Return the directly accessible array names (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code>()</p></td>
<td><p>Tries to load a copy of this snapshot, using partial loading to select only a subset of particles corresponding to a given SubSnap</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loadable_keys</span></code>([fam])</p></td>
<td><p>Returns a list of arrays which can be lazy-loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_by_mass</span></code>(name)</p></td>
<td><p>Calculate the mean by mass of the specified array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">original_units</span></code>()</p></td>
<td><p>Converts all arrays’units to be consistent with the units of the original file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">physical_units</span></code>(*args, **kwargs)</p></td>
<td><p>Converts all array’s units to be consistent with the distance, velocity, mass basis units specified.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_x</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_y</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_z</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_system</span></code>([velocity, distance, mass, …])</p></td>
<td><p>Set the unit system for the snapshot by specifying any or all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite> units.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdiff</span></code>(other)</p></td>
<td><p>Returns the set difference of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(matrix)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other)</p></td>
<td><p>Returns the set union of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlink_array</span></code>(name)</p></td>
<td><p>If the named array is auto-derived, this destroys the link so that the array becomes editable but no longer auto-updates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p>Returns a list of the actual arrays in memory</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code>([boxsize, convention])</p></td>
<td><p>Wraps the positions of the particles in the box to lie between [-boxsize/2, boxsize/2].</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code>([fmt, filename])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_array</span></code>(array_name[, fam])</p></td>
<td><p>Write out the array with the specified name.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>decorator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iteritems</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>iterkeys</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>itervalues</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>stable_derived_quantity</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.halo.Halo.is_subhalo">
<code class="sig-name descname">is_subhalo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">otherhalo</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#Halo.is_subhalo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.Halo.is_subhalo" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that calls the corresponding function in
a halo catalogue.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.halo.HaloCatalogue">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.halo.</code><code class="sig-name descname">HaloCatalogue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#HaloCatalogue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.HaloCatalogue" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic halo catalogue object.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.halo.HaloCatalogue.get_group_array" title="pynbody.halo.HaloCatalogue.get_group_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_group_array</span></code></a>()</p></td>
<td><p>Return an array with an integer for each particle in the simulation indicating which halo that particle is associated with.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.halo.HaloCatalogue.is_subhalo" title="pynbody.halo.HaloCatalogue.is_subhalo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_subhalo</span></code></a>(childid, parentid)</p></td>
<td><p>Checks whether the specified ‘childid’ halo is a subhalo of ‘parentid’ halo.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calc_item</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>contains</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.halo.HaloCatalogue.is_subhalo">
<code class="sig-name descname">is_subhalo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">childid</span></em>, <em class="sig-param"><span class="n">parentid</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#HaloCatalogue.is_subhalo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.HaloCatalogue.is_subhalo" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the specified ‘childid’ halo is a subhalo
of ‘parentid’ halo.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.halo.HaloCatalogue.get_group_array">
<code class="sig-name descname">get_group_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#HaloCatalogue.get_group_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.HaloCatalogue.get_group_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with an integer for each particle in the simulation
indicating which halo that particle is associated with. If there are multiple
levels (i.e. subhalos), the number returned corresponds to the lowest level, i.e.
the smallest subhalo.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.halo.GrpCatalogue">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.halo.</code><code class="sig-name descname">GrpCatalogue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">array</span><span class="o">=</span><span class="default_value">'grp'</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#GrpCatalogue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.GrpCatalogue" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic catalogue using a .grp file to specify which particles
belong to which group.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.halo.GrpCatalogue.get_group_array" title="pynbody.halo.GrpCatalogue.get_group_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_group_array</span></code></a>([family])</p></td>
<td><p>Return an array with an integer for each particle in the simulation indicating which halo that particle is associated with.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_subhalo</span></code>(childid, parentid)</p></td>
<td><p>Checks whether the specified ‘childid’ halo is a subhalo of ‘parentid’ halo.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.halo.GrpCatalogue.load_copy" title="pynbody.halo.GrpCatalogue.load_copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code></a>(i)</p></td>
<td><p>Load the a fresh SimSnap with only the particle in halo i</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.halo.GrpCatalogue.precalculate" title="pynbody.halo.GrpCatalogue.precalculate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">precalculate</span></code></a>()</p></td>
<td><p>Speed up future operations by precalculating the indices for all halos in one operation.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calc_item</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>contains</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.halo.GrpCatalogue.precalculate">
<code class="sig-name descname">precalculate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#GrpCatalogue.precalculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.GrpCatalogue.precalculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Speed up future operations by precalculating the indices
for all halos in one operation. This is slow compared to
getting a single halo, however.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.halo.GrpCatalogue.get_group_array">
<code class="sig-name descname">get_group_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#GrpCatalogue.get_group_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.GrpCatalogue.get_group_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with an integer for each particle in the simulation
indicating which halo that particle is associated with. If there are multiple
levels (i.e. subhalos), the number returned corresponds to the lowest level, i.e.
the smallest subhalo.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.halo.GrpCatalogue.load_copy">
<code class="sig-name descname">load_copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#GrpCatalogue.load_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.GrpCatalogue.load_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the a fresh SimSnap with only the particle in halo i</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.halo.AmigaGrpCatalogue">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.halo.</code><code class="sig-name descname">AmigaGrpCatalogue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">arr_name</span><span class="o">=</span><span class="default_value">'amiga.grp'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/halo.html#AmigaGrpCatalogue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.halo.AmigaGrpCatalogue" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_group_array</span></code>([family])</p></td>
<td><p>Return an array with an integer for each particle in the simulation indicating which halo that particle is associated with.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_subhalo</span></code>(childid, parentid)</p></td>
<td><p>Checks whether the specified ‘childid’ halo is a subhalo of ‘parentid’ halo.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code>(i)</p></td>
<td><p>Load the a fresh SimSnap with only the particle in halo i</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">precalculate</span></code>()</p></td>
<td><p>Speed up future operations by precalculating the indices for all halos in one operation.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calc_item</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>contains</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<span class="target" id="module-pynbody.sph"></span><div class="section" id="sph">
<h2>sph<a class="headerlink" href="#sph" title="Permalink to this headline">¶</a></h2>
<p>pynbody SPH rendering module.</p>
<p>This module encompasses Kernel objects, which return C fragments from which
a final C code to perform the rendering is derived.</p>
<p>For most users, the function of interest will be <a class="reference internal" href="#pynbody.sph.render_image" title="pynbody.sph.render_image"><code class="xref py py-func docutils literal notranslate"><span class="pre">render_image()</span></code></a>.</p>
<dl class="py function">
<dt id="pynbody.sph.render_spherical_image">
<code class="sig-prename descclassname">pynbody.sph.</code><code class="sig-name descname">render_spherical_image</code><span class="sig-paren">(</span><em class="sig-param">snap</em>, <em class="sig-param">qty='rho'</em>, <em class="sig-param">nside=8</em>, <em class="sig-param">distance=10.0</em>, <em class="sig-param">kernel=&lt;pynbody.sph.Kernel object&gt;</em>, <em class="sig-param">kstep=0.5</em>, <em class="sig-param">denoise=None</em>, <em class="sig-param">out_units=None</em>, <em class="sig-param">threaded=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/sph.html#render_spherical_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.render_spherical_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Render an SPH image on a spherical surface. Requires healpy libraries.</p>
<p><strong>Keyword arguments:</strong></p>
<p><em>qty</em> (‘rho’): The name of the simulation array to render</p>
<p><em>nside</em> (8): The healpix nside resolution to use (must be power of 2)</p>
<dl class="simple">
<dt><em>distance</em> (10.0): The distance of the shell (for 3D kernels) or maximum distance</dt><dd><p>of the skewers (2D kernels)</p>
</dd>
</dl>
<p><em>kernel</em>: The Kernel object to use (defaults to 3D spline kernel)</p>
<dl class="simple">
<dt><em>kstep</em> (0.5): The sampling distance when projecting onto the spherical surface in units of the</dt><dd><p>smoothing length</p>
</dd>
<dt><em>denoise</em> (False): if True, divide through by an estimate of the discreteness noise.</dt><dd><p>The returned image is then not strictly an SPH estimate, but this option can be
useful to reduce noise.</p>
</dd>
<dt><em>threaded</em>: if False, render on a single core. Otherwise, the number of threads to use.</dt><dd><p>Defaults to a value specified in your configuration files. <em>Currently multi-threaded
rendering is slower than single-threaded because healpy does not release the gil</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynbody.sph.render_image">
<code class="sig-prename descclassname">pynbody.sph.</code><code class="sig-name descname">render_image</code><span class="sig-paren">(</span><em class="sig-param">snap</em>, <em class="sig-param">qty='rho'</em>, <em class="sig-param">x2=100</em>, <em class="sig-param">nx=500</em>, <em class="sig-param">y2=None</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">x1=None</em>, <em class="sig-param">y1=None</em>, <em class="sig-param">z_plane=0.0</em>, <em class="sig-param">out_units=None</em>, <em class="sig-param">xy_units=None</em>, <em class="sig-param">kernel=&lt;pynbody.sph.Kernel object&gt;</em>, <em class="sig-param">z_camera=None</em>, <em class="sig-param">smooth='smooth'</em>, <em class="sig-param">smooth_in_pixels=False</em>, <em class="sig-param">force_quiet=False</em>, <em class="sig-param">approximate_fast=True</em>, <em class="sig-param">threaded=None</em>, <em class="sig-param">denoise=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/sph.html#render_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.render_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Render an SPH image using a typical (mass/rho)-weighted ‘scatter’
scheme.</p>
<p><strong>Keyword arguments:</strong></p>
<p><em>qty</em> (‘rho’): The name of the array within the simulation to render</p>
<p><em>x2</em> (100.0): The x-coordinate of the right edge of the image</p>
<p><em>nx</em> (500): The number of pixels wide to make the image</p>
<dl class="simple">
<dt><em>y2</em>: The y-coordinate of the upper edge of the image (default x2,</dt><dd><p>or if ny is specified, x2*ny/nx)</p>
</dd>
</dl>
<p><em>ny</em> (nx): The number of pixels tall to make the image</p>
<p><em>x1</em> (-x2): The x-coordinate of the left edge of the image</p>
<p><em>y1</em> (-y2): The y-coordinate of the lower edge of the image</p>
<p><em>z_plane</em> (0.0): The z-coordinate of the plane of the image</p>
<p><em>out_units</em> (no conversion): The units to convert the output image into</p>
<p><em>xy_units</em>: The units for the x and y axes</p>
<p><em>kernel</em>: The Kernel object to use (default Kernel(), a 3D spline kernel)</p>
<dl>
<dt><em>z_camera</em>: If this is set, a perspective image is rendered,</dt><dd><p>assuming the kernel is suitable (i.e. is a projecting
kernel). The camera is at the specified z coordinate looking
towards -ve z, and each pixel represents a line-of-sight radially
outwards from the camera. The width then specifies the width of
the image in the z=0 plane. Particles too close to the camera are
also excluded.</p>
<dl class="simple">
<dt><em>smooth</em>: The name of the array which contains the smoothing lengths</dt><dd><p>(default ‘smooth’)</p>
</dd>
<dt><em>smooth_in_pixels</em>: If True, the smoothing array contains the smoothing</dt><dd><p>length in image pixels, rather than in real distance units (default False)</p>
</dd>
<dt><em>approximate_fast</em>: if True, render high smoothing length particles at</dt><dd><p>progressively lower resolution, resample and sum</p>
</dd>
<dt><em>denoise</em>: if True, divide through by an estimate of the discreteness noise.</dt><dd><p>The returned image is then not strictly an SPH estimate, but this option
can be useful to reduce noise especially when rendering AMR grids which
often introduce problematic edge effects.</p>
</dd>
</dl>
<p><em>verbose</em>: if True, all text output suppressed</p>
<dl class="simple">
<dt><em>threaded</em>: if False (or None), render on a single core. Otherwise,</dt><dd><p>the number of threads to use (defaults to a value specified in your
configuration files).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynbody.sph.to_3d_grid">
<code class="sig-prename descclassname">pynbody.sph.</code><code class="sig-name descname">to_3d_grid</code><span class="sig-paren">(</span><em class="sig-param">snap</em>, <em class="sig-param">qty='rho'</em>, <em class="sig-param">nx=None</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">nz=None</em>, <em class="sig-param">x2=None</em>, <em class="sig-param">out_units=None</em>, <em class="sig-param">xy_units=None</em>, <em class="sig-param">kernel=&lt;pynbody.sph.Kernel object&gt;</em>, <em class="sig-param">smooth='smooth'</em>, <em class="sig-param">approximate_fast=True</em>, <em class="sig-param">threaded=None</em>, <em class="sig-param">snap_slice=None</em>, <em class="sig-param">denoise=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/sph.html#to_3d_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.to_3d_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Project SPH onto a grid using a typical (mass/rho)-weighted ‘scatter’
scheme.</p>
<p><strong>Keyword arguments:</strong></p>
<p><em>qty</em> (‘rho’): The name of the array within the simulation to render</p>
<p><em>nx</em> (x2-x1 / soft): The number of pixels wide to make the grid</p>
<p><em>ny</em> (nx): The number of pixels tall to make the grid</p>
<p><em>nz</em> (nx): The number of pixels deep to make the grid</p>
<p><em>out_units</em> (no conversion): The units to convert the output grid into</p>
<p><em>xy_units</em>: The units for the x and y axes</p>
<p><em>kernel</em>: The Kernel object to use (default Kernel(), a 3D spline kernel)</p>
<dl class="simple">
<dt><em>smooth</em>: The name of the array which contains the smoothing lengths</dt><dd><p>(default ‘smooth’)</p>
</dd>
<dt><em>denoise</em>: if True, divide through by an estimate of the discreteness noise.</dt><dd><p>The returned image is then not strictly an SPH estimate, but this option
can be useful to reduce noise especially when rendering AMR grids which
often introduce problematic edge effects.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pynbody.sph.spectra">
<code class="sig-prename descclassname">pynbody.sph.</code><code class="sig-name descname">spectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snap</span></em>, <em class="sig-param"><span class="n">qty</span><span class="o">=</span><span class="default_value">'rho'</span></em>, <em class="sig-param"><span class="n">x1</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">y1</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">v2</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">nvel</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">v1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">element</span><span class="o">=</span><span class="default_value">'H'</span></em>, <em class="sig-param"><span class="n">ion</span><span class="o">=</span><span class="default_value">'I'</span></em>, <em class="sig-param"><span class="n">xy_units</span><span class="o">=</span><span class="default_value">Unit('kpc')</span></em>, <em class="sig-param"><span class="n">vel_units</span><span class="o">=</span><span class="default_value">Unit('km s**-1')</span></em>, <em class="sig-param"><span class="n">smooth</span><span class="o">=</span><span class="default_value">'smooth'</span></em>, <em class="sig-param"><span class="n">__threaded</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/sph.html#spectra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Render an SPH spectrum using a (mass/rho)-weighted ‘scatter’
scheme of all the particles that have a smoothing length within
2 h_sm of the position.</p>
<p><strong>Keyword arguments:</strong></p>
<p><em>qty</em> (‘rho’): The name of the array within the simulation to render</p>
<p><em>x1</em> (0.0): The x-coordinate of the line of sight.</p>
<p><em>y1</em> (0.0): The y-coordinate of the line of sight.</p>
<p><em>v1</em> (-400.0): The minimum velocity of the spectrum</p>
<p><em>v2</em> (400.0): The maximum velocity of the spectrum</p>
<p><em>nvel</em> (500): The number of resolution elements in spectrum</p>
<p><em>xy_units</em> (‘kpc’): The units for the x and y axes</p>
<dl class="simple">
<dt><em>smooth</em>: The name of the array which contains the smoothing lengths</dt><dd><p>(default ‘smooth’)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorials.html">Tutorials &amp; walkthroughs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Pynbody reference documentation</a><ul>
      <li>Previous: <a href="essentials.html" title="previous chapter">Essential Framework Modules</a></li>
      <li>Next: <a href="derived.html" title="next chapter">Automatically Derived Arrays</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2011-20, pynbody team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/reference/convenience.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>