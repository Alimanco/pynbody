
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Essential Framework Modules &#8212; pynbody 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generic Convenience Modules" href="convenience.html" />
    <link rel="prev" title="Pynbody reference documentation" href="index.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

<link href="https://fonts.googleapis.com/css?family=Quicksand" rel="stylesheet">
<link href="_static/customise.css" rel="stylesheet">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38063425-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pynbody.array">
<span id="essential-framework-modules"></span><h1>Essential Framework Modules<a class="headerlink" href="#module-pynbody.array" title="Permalink to this headline">¶</a></h1>
<div class="section" id="array">
<h2>array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h2>
<p>Defines a shallow wrapper around numpy.ndarray for extra functionality like unit-tracking.</p>
<p>For most purposes, the differences between numpy.ndarray and
array.SimArray are not important. However, when units are specified
(by setting the <code class="docutils literal notranslate"><span class="pre">units</span></code> attribute), the behaviour is slightly
different. In particular,</p>
<ul class="simple">
<li><p>it becomes impossible to add or subtract arrays with incompatible dimensions</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Mpc&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Msol&quot;</span><span class="p">))</span>
<span class="go">ValueError</span>
</pre></div>
</div>
<ul class="simple">
<li><p>addition or subtraction causes auto-unit conversion. For example</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Mpc&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;kpc&quot;</span><span class="p">)</span>
<span class="go">SimArray([1.001, 1.002], &quot;Mpc&quot;)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Note that in this context the left value takes precedence in
specifying the return units, so that reversing the order of the
operation here would return results in kpc.</p></li>
<li><p>If only one of the arrays specifies a Unit, no checking occurs and
the unit of the returned array is assumed to be the same as the one
specified input unit.</p></li>
<li><p>Powers to single integer or rational powers will maintain unit
tracking.  Powers to float or other powers will not be able to do
so.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s2">&quot;Msol Mpc**-3&quot;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="go">SimArray([1, 4], &#39;Msol**2 Mpc**-6&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s2">&quot;Msol Mpc**-3&quot;</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">SimArray([ 1.,1.26], &#39;Msol**1/3 Mpc**-1&#39;)</span>
</pre></div>
</div>
<p>Syntax above mirrors syntax in units module, where a length-two tuple
can represent a rational number, in this case one third.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimArray</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Msol Mpc**-3&quot;</span><span class="p">)</span><span class="o">**</span><span class="mf">0.333</span>
<span class="go">SimArray([ 1.,1.26])  # Lost track of units</span>
</pre></div>
</div>
<div class="section" id="getting-the-array-in-specified-units">
<h3><em>Getting the array in specified units</em><a class="headerlink" href="#getting-the-array-in-specified-units" title="Permalink to this headline">¶</a></h3>
<p>Given an array, you can convert it in-place into units of your
own chosing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Msol&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="s1">&#39;kg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">x</span>
<span class="go">SimArray([  1.99e+30,   3.98e+30], &#39;kg&#39;)</span>
</pre></div>
</div>
<p>Or you can leave the original array alone and get a <em>copy</em> in
different units, correctly converted:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">SimArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Msol&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">x</span><span class="o">.</span><span class="n">in_units</span><span class="p">(</span><span class="s2">&quot;kg&quot;</span><span class="p">)</span>
<span class="go">SimArray([  1.99e+30,   3.98e+30], &#39;kg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">x</span>
<span class="go">SimArray([1,2], &quot;Msol&quot;)</span>
</pre></div>
</div>
<p>If the SimArray was created by a SimSnap (which is most likely), it
has a pointer into the SimSnap’s properties so that the cosmological
context is automatically fetched. For example, comoving -&gt; physical
conversions are correctly achieved:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">pynbody</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;fname&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
<span class="go">SimArray([[ 0.05419805, -0.0646539 , -0.15700017],</span>
<span class="go">         [ 0.05169899, -0.06193341, -0.14475258],</span>
<span class="go">         [ 0.05672406, -0.06384531, -0.15909944],</span>
<span class="go">         ...,</span>
<span class="go">         [ 0.0723075 , -0.07650762, -0.07657281],</span>
<span class="go">         [ 0.07166634, -0.07453796, -0.08020873],</span>
<span class="go">         [ 0.07165282, -0.07468577, -0.08020587]], &#39;2.86e+04 kpc a&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="s1">&#39;kpc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
<span class="go">SimArray([[ 1548.51403101, -1847.2525312 , -4485.71463308],</span>
<span class="go">         [ 1477.1124212 , -1769.52421398, -4135.78377699],</span>
<span class="go">         [ 1620.68592366, -1824.15000686, -4545.69387564],</span>
<span class="go">         ...,</span>
<span class="go">         [ 2065.9264273 , -2185.92982874, -2187.79225915],</span>
<span class="go">         [ 2047.60759667, -2129.6537339 , -2291.6758134 ],</span>
<span class="go">         [ 2047.2214441 , -2133.87693163, -2291.59406997]], &#39;kpc&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-rules-for-ufunc-s">
<h3><em>Specifying rules for ufunc’s</em><a class="headerlink" href="#specifying-rules-for-ufunc-s" title="Permalink to this headline">¶</a></h3>
<p>In general, it’s not possible to infer what the output units from a given
ufunc should be. While numpy built-in ufuncs should be handled OK, other
ufuncs will need their output units defined (otherwise a numpy.ndarray
will be returned instead of our custom type.)</p>
<p>To do this, decorate a function with SimArray.ufunc_rule(ufunc). The function
you define should take the same number of parameters as the ufunc. These will
be the input parameters of the ufunc. You should return the correct units for
the output, or raise units.UnitsException (in the latter case, the return
array will be made into a numpy.ndarray.)</p>
<p>For example, here is the code for the correct addition/subtraction
handler:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@SimArray</span><span class="o">.</span><span class="n">ufunc_rule</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="nd">@SimArray</span><span class="o">.</span><span class="n">ufunc_rule</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_consistent_units</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">:</span>

    <span class="c1"># This will be called whenever the standard numpy ufuncs np.add</span>
    <span class="c1"># or np.subtract are called with parameters a,b.</span>

    <span class="c1"># You should always be ready for the inputs to have no units.</span>

    <span class="n">a_units</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">units</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">b_units</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">units</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Now do the logic. If we&#39;re adding incompatible units,</span>
    <span class="c1"># we want just to get a plain numpy array out. If we only</span>
    <span class="c1"># know the units of one of the arrays, we assume the output</span>
    <span class="c1"># is in those units.</span>

    <span class="k">if</span> <span class="n">a_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">a_units</span><span class="o">==</span><span class="n">b_units</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">a_units</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">units</span><span class="o">.</span><span class="n">UnitsException</span><span class="p">(</span><span class="s2">&quot;Incompatible units&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">a_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">a_units</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">b_units</span>
</pre></div>
</div>
<dl class="py class">
<dt id="pynbody.array.SimArray">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">SimArray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">units</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sim</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a shallow wrapper around numpy.ndarray for extra
functionality like unit-tracking.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>The transposed array.</p>
</dd>
<dt><a class="reference internal" href="#pynbody.array.SimArray.ancestor" title="pynbody.array.SimArray.ancestor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></a></dt><dd><p>Provides the basemost SimArray that an IndexedSimArray is based on.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><strong>derived</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt><dd><p>Data-type of the array’s elements.</p>
</dd>
<dt><strong>family</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt><dd><p>The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>
</dd>
<dt><strong>name</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt><dd><p>Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt><dd><p>The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>
</dd>
<dt><strong>sim</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
<dt><strong>units</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if all elements evaluate to True.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis, out])</p></td>
<td><p>Return indices of the maximum values along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis, out])</p></td>
<td><p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Returns the indices that would partition this array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis, kind, order])</p></td>
<td><p>Returns the indices that would sort this array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[, order, casting, subok, copy])</p></td>
<td><p>Copy of the array, cast to a specified type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>([inplace])</p></td>
<td><p>Swap the bytes of the array elements</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[, out, mode])</p></td>
<td><p>Use an index array to construct a new array from a set of choices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min, max, out])</p></td>
<td><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[, axis, out])</p></td>
<td><p>Return selected slices of this array along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</p></td>
<td><p>Complex-conjugate all elements.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</p></td>
<td><p>Return the complex conjugate, element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.convert_units" title="pynbody.array.SimArray.convert_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code></a>(new_unit)</p></td>
<td><p>Convert units of this array in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</p></td>
<td><p>Return a copy of the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative product of the elements along the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.cumsum" title="pynbody.array.SimArray.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>([axis, dtype, out])</p></td>
<td><p>Return the cumulative sum of the elements along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset, axis1, axis2])</p></td>
<td><p>Return specified diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[, out])</p></td>
<td><p>Dot product of two arrays.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</p></td>
<td><p>Dump a pickle of the array to the specified file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</p></td>
<td><p>Returns the pickle of the array as a string.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</p></td>
<td><p>Fill the array with a scalar value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</p></td>
<td><p>Return a copy of the array collapsed into one dimension.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[, offset])</p></td>
<td><p>Returns a field of the given array as a certain type.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.in_original_units" title="pynbody.array.SimArray.in_original_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_original_units</span></code></a>()</p></td>
<td><p>Retun a copy of this array expressed in the units specified in the parameter file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.in_units" title="pynbody.array.SimArray.in_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code></a>(new_unit, **context_overrides)</p></td>
<td><p>Return a copy of this array expressed relative to an alternative unit.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</p></td>
<td><p>Copy an element of an array to a standard Python scalar and return it.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</p></td>
<td><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.max" title="pynbody.array.SimArray.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>([axis, out, keepdims, initial, where])</p></td>
<td><p>Return the maximum along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.mean" title="pynbody.array.SimArray.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([axis, dtype, out, keepdims])</p></td>
<td><p>Returns the average of the array elements along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.min" title="pynbody.array.SimArray.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>([axis, out, keepdims, initial, where])</p></td>
<td><p>Return the minimum along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</p></td>
<td><p>Return the array with the same data viewed with a different byte order.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</p></td>
<td><p>Return the indices of the elements that are non-zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.prod" title="pynbody.array.SimArray.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>([axis, dtype, out, keepdims, initial, …])</p></td>
<td><p>Return the product of the array elements over the given axis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.ptp" title="pynbody.array.SimArray.ptp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code></a>([axis, out, keepdims])</p></td>
<td><p>Peak to peak (maximum - minimum) value along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices, values[, mode])</p></td>
<td><p>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</p></td>
<td><p>Return a flattened array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[, axis])</p></td>
<td><p>Repeat elements of an array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[, order])</p></td>
<td><p>Returns an array containing the same data with a new shape.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code>(new_shape[, refcheck])</p></td>
<td><p>Change shape and size of array in-place.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals, out])</p></td>
<td><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[, side, sorter])</p></td>
<td><p>Find indices where elements of v should be inserted in a to maintain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.set_default_units" title="pynbody.array.SimArray.set_default_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_default_units</span></code></a>([quiet])</p></td>
<td><p>Set the units for this array by performing dimensional analysis on the default dimensions for the array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.set_units_like" title="pynbody.array.SimArray.set_units_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_like</span></code></a>(new_unit)</p></td>
<td><p>Set the units for this array by performing dimensional analysis on the supplied unit and referring to the units of the original file</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val, dtype[, offset])</p></td>
<td><p>Put a value into a specified place in a field defined by a data-type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write, align, uic])</p></td>
<td><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis, kind, order])</p></td>
<td><p>Sort an array in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</p></td>
<td><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.std" title="pynbody.array.SimArray.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the standard deviation of the array elements along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.array.SimArray.sum" title="pynbody.array.SimArray.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>([axis, dtype, out, keepdims, initial, where])</p></td>
<td><p>Return the sum of the array elements over the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1, axis2)</p></td>
<td><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[, axis, out, mode])</p></td>
<td><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[, sep, format])</p></td>
<td><p>Write array to a file as text or binary (default).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</p></td>
<td><p>Return the array as an <code class="docutils literal notranslate"><span class="pre">a.ndim</span></code>-levels deep nested list of Python scalars.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset, axis1, axis2, dtype, out])</p></td>
<td><p>Return the sum along diagonals of the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</p></td>
<td><p>Returns a view of the array with axes transposed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.var" title="pynbody.array.SimArray.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the variance of the array elements, along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype, type])</p></td>
<td><p>New view of array with the same data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.array.SimArray.write" title="pynbody.array.SimArray.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(**kwargs)</p></td>
<td><p>Write this array to disk according to the standard method associated with its base file.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>abs</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>conversion_context</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>mean_by_mass</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>ufunc_rule</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.array.SimArray.ancestor">
<em class="property">property </em><code class="sig-name descname">ancestor</code><a class="headerlink" href="#pynbody.array.SimArray.ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the basemost SimArray that an IndexedSimArray is based on.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.cumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumsum</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.cumsum</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.prod</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the array elements over the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.sum</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the array elements along given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.mean</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=&lt;no value&gt;</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum along a given axis.</p>
<p>Refer to <cite>numpy.amax</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.amax</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=&lt;no value&gt;</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum along a given axis.</p>
<p>Refer to <cite>numpy.amin</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.amin</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.ptp">
<code class="sig-name descname">ptp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.ptp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak to peak (maximum - minimum) value along a given axis.</p>
<p>Refer to <cite>numpy.ptp</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ptp</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.std"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the standard deviation of the array elements along given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.std</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variance of the array elements, along given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.var</span></code></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.set_units_like">
<code class="sig-name descname">set_units_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_unit</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.set_units_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.set_units_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the units for this array by performing dimensional analysis
on the supplied unit and referring to the units of the original
file</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.set_default_units">
<code class="sig-name descname">set_default_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.set_default_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.set_default_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the units for this array by performing dimensional analysis
on the default dimensions for the array.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.in_original_units">
<code class="sig-name descname">in_original_units</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.in_original_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.in_original_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Retun a copy of this array expressed in the units
specified in the parameter file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.in_units">
<code class="sig-name descname">in_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_unit</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">context_overrides</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.in_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.in_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this array expressed relative to an alternative
unit.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.convert_units">
<code class="sig-name descname">convert_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_unit</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.convert_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert units of this array in-place. Note that if
this is a sub-view, the entire base array will be converted.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.array.SimArray.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#SimArray.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.SimArray.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write this array to disk according to the standard method
associated with its base file. This is equivalent to calling</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">gas</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>in the case of writing out the array ‘array’ for the gas
particle family.  See the description of
<a class="reference internal" href="#pynbody.snapshot.SimSnap.write_array" title="pynbody.snapshot.SimSnap.write_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">pynbody.snapshot.SimSnap.write_array()</span></code></a> for options.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynbody.array.wrapper_function">
<code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">wrapper_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#wrapper_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.wrapper_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py exception">
<dt id="pynbody.array.RemoteKeyboardInterrupt">
<em class="property">exception </em><code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">RemoteKeyboardInterrupt</code><a class="reference internal" href="../_modules/pynbody/array.html#RemoteKeyboardInterrupt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.RemoteKeyboardInterrupt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pynbody.array.f">
<code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">f</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynbody.array.f" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.array.shared_array_remote">
<code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">shared_array_remote</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fn</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#shared_array_remote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.shared_array_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for functions returning a new function that is
suitable for use remotely. Inputs to and outputs from the function
can be transferred efficiently if they are backed onto shared
memory. Ownership of any shared memory returned by the function
is transferred.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.array.remote_map">
<code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">remote_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pool</span></em>, <em class="sig-param"><span class="n">fn</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">iterables</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#remote_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.remote_map" title="Permalink to this definition">¶</a></dt>
<dd><p>A replacement for python’s in-built map function, sending out tasks
to the pool and performing the magic required to transport shared memory arrays
correctly. The function <em>fn</em> must be wrapped with the <em>shared_array_remote</em>
decorator to interface correctly with this magic.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.array.exit_cleanup">
<code class="sig-prename descclassname">pynbody.array.</code><code class="sig-name descname">exit_cleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/array.html#exit_cleanup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.array.exit_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up any shared memory that has not yet been freed. In
theory this should not be required, but it is here as a safety
net.</p>
</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.simdict"></span><div class="section" id="simdict">
<h2>simdict<a class="headerlink" href="#simdict" title="Permalink to this headline">¶</a></h2>
<p>This submodule defines an augmented dictionary class
(<a class="reference internal" href="#pynbody.simdict.SimDict" title="pynbody.simdict.SimDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimDict</span></code></a>) for <a class="reference internal" href="#pynbody.snapshot.SimSnap" title="pynbody.snapshot.SimSnap"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimSnap</span></code></a> properties
where entries need to be managed e.g.  for defining default entries,
or for ensuring consistency between equivalent properties like
redshift and scalefactor.</p>
<p>By default, a <a class="reference internal" href="#pynbody.simdict.SimDict" title="pynbody.simdict.SimDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimDict</span></code></a> automatically converts between
redshift (‘z’) and scalefactor (‘a’) and implements default entries
for cosmological values listed in the [default-cosmology] section of
the <cite>pynbody</cite> configuration files.</p>
<div class="section" id="adding-further-properties">
<h3>Adding further properties<a class="headerlink" href="#adding-further-properties" title="Permalink to this headline">¶</a></h3>
<p>To add further properties use the SimDict.getter and SimDict.setter decorators.
For instance, to add a property ‘X_copy’ which just reflects the value of the
property ‘X’, you would use the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@SimDict</span><span class="o">.</span><span class="n">getter</span>
<span class="k">def</span> <span class="nf">X_copy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>

<span class="nd">@SimDict</span><span class="o">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">X_copy</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<dl class="py class">
<dt id="pynbody.simdict.SimDict">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.simdict.</code><code class="sig-name descname">SimDict</code><span class="sig-paren">(</span><em class="sig-param">) -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's (key</em>, <em class="sig-param">value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k</em>, <em class="sig-param">v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1</em>, <em class="sig-param">two=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/simdict.html#SimDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.simdict.SimDict" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code>(iterable[, value])</p></td>
<td><p>Create a new dictionary with keys from iterable and values set to value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(key[, default])</p></td>
<td><p>Return the value for key if key is in the dictionary, else default.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.simdict.SimDict.getter" title="pynbody.simdict.SimDict.getter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getter</span></code></a>(f)</p></td>
<td><p>Define a getter function for all SimDicts</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code>(k[,d])</p></td>
<td><p>If key is not found, d is returned if given, otherwise KeyError is raised</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code>(/)</p></td>
<td><p>Remove and return a (key, value) pair as a 2-tuple.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code>(key[, default])</p></td>
<td><p>Insert key with a value of default if key is not in the dictionary.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.simdict.SimDict.setter" title="pynbody.simdict.SimDict.setter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setter</span></code></a>(f)</p></td>
<td><p>Define a setter function for all SimDicts</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>([E, ]**F)</p></td>
<td><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.simdict.SimDict.getter">
<em class="property">static </em><code class="sig-name descname">getter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/simdict.html#SimDict.getter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.simdict.SimDict.getter" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a getter function for all SimDicts</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.simdict.SimDict.setter">
<em class="property">static </em><code class="sig-name descname">setter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/simdict.html#SimDict.setter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.simdict.SimDict.setter" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a setter function for all SimDicts</p>
</dd></dl>

</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.family"></span><div class="section" id="family">
<h2>family<a class="headerlink" href="#family" title="Permalink to this headline">¶</a></h2>
<p>This module defines the Family class which represents
families of particles (e.g. dm, gas, star particles).
New Family objects are automatically registered so that
snapshots can use them in the normal syntax (snap.dm,
snap.star, etc).</p>
<p>In practice the easiest way to make use of the flexibility
this module provides is through adding more families of
particles in your config.ini.</p>
<dl class="py function">
<dt id="pynbody.family.family_names">
<code class="sig-prename descclassname">pynbody.family.</code><code class="sig-name descname">family_names</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">with_aliases</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/family.html#family_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.family.family_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the names of all particle families.
If with_aliases is True, include aliases in the list.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.family.get_family">
<code class="sig-prename descclassname">pynbody.family.</code><code class="sig-name descname">get_family</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">create</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/family.html#get_family"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.family.get_family" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a family corresponding to the specified string.  If the
family does not exist and create is False, raises ValueError. If
the family does not exist and create is True, an appropriate
object is instantiated, registered and returned.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.snapshot"></span><div class="section" id="snapshot">
<h2>snapshot<a class="headerlink" href="#snapshot" title="Permalink to this headline">¶</a></h2>
<p>This module implements the  <a class="reference internal" href="#pynbody.snapshot.SimSnap" title="pynbody.snapshot.SimSnap"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimSnap</span></code></a> class which manages and stores snapshot data.
It also implements the <a class="reference internal" href="#pynbody.snapshot.SubSnap" title="pynbody.snapshot.SubSnap"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubSnap</span></code></a> class (and relatives) which
represent different views of an existing <a class="reference internal" href="#pynbody.snapshot.SimSnap" title="pynbody.snapshot.SimSnap"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimSnap</span></code></a>.</p>
<dl class="py class">
<dt id="pynbody.snapshot.SimSnap">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">SimSnap</code><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>The class for managing simulation snapshots.</p>
<p>For most purposes, SimSnaps should be initialized through
<code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code> or <code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code>.</p>
<p>For a basic tutorial explaining how to load a file as a SimSnap
see <span class="xref std std-doc">tutorials/data_access</span>.</p>
<p><em>Getting arrays or subsnaps</em></p>
<p>Once a <a class="reference internal" href="#pynbody.snapshot.SimSnap" title="pynbody.snapshot.SimSnap"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimSnap</span></code></a> object <code class="docutils literal notranslate"><span class="pre">f</span></code> is instantiated, it can
be used in various ways. The most common operation is to
access something with the code <code class="docutils literal notranslate"><span class="pre">f[x]</span></code>.  Depending on the
type of <code class="docutils literal notranslate"><span class="pre">x</span></code>, various behaviours result:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a string, the array named by <code class="docutils literal notranslate"><span class="pre">x</span></code> is returned. If
no such array exists, the framework attempts to load or
derive an array of that name (in that order). If this is
unsuccessful, a <cite>KeyError</cite> is raised.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a python <cite>slice</cite> (e.g. <code class="docutils literal notranslate"><span class="pre">f[5:100:3]</span></code>) or an array of
integers (e.g. <code class="docutils literal notranslate"><span class="pre">f[[1,5,100,200]]</span></code>) a subsnap containing only the
mentioned particles is returned.</p>
<p>See <span class="xref std std-doc">tutorials/data_access</span> for more information.</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a numpy array of booleans, it is interpreted as a mask and
a subsnap containing only those particles for which x[i] is True.
This means that f[condition] is a shortcut for f[np.where(condition)].</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">pynbody.filt.Filter</span></code> object, a subsnap
containing only the particles which pass the filter condition
is returned.</p>
<p>See <span class="xref std std-doc">tutorials/data_access</span> for more information.</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">pynbody.family.Family</span></code> object, a subsnap
containing only the particles in that family is returned. In practice
for most code it is more convenient to write e.g. <code class="docutils literal notranslate"><span class="pre">f.dm</span></code> in place of
the equivalent syntax f[pynbody.family.dm].</p></li>
</ul>
<p><em>Getting metadata</em></p>
<p>The property <cite>filename</cite> gives the filename of a snapshot.</p>
<p>There is also a <cite>properties</cite> dictionary which
contains further metadata about the snapshot. See <a class="reference internal" href="../tutorials/data_access.html#subsnaps"><span class="std std-ref">Subsnaps</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#pynbody.snapshot.SimSnap.ancestor" title="pynbody.snapshot.SimSnap.ancestor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></a></dt><dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd>
<dt><strong>filename</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.all_keys" title="pynbody.snapshot.SimSnap.all_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_keys</span></code></a>()</p></td>
<td><p>Returns a list of all arrays that can be either lazy-evaluated or lazy loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.bridge" title="pynbody.snapshot.SimSnap.bridge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bridge</span></code></a>(other)</p></td>
<td><p>Tries to construct a bridge function between this SimSnap and another one.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.conversion_context" title="pynbody.snapshot.SimSnap.conversion_context"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conversion_context</span></code></a>()</p></td>
<td><p>Return a dictionary containing a (scalefactor) and h (Hubble constant in canonical units) for this snapshot, ready for passing into unit conversion functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.derivable_keys" title="pynbody.snapshot.SimSnap.derivable_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivable_keys</span></code></a>()</p></td>
<td><p>Returns a list of arrays which can be lazy-evaluated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derived_quantity</span></code>(fn)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.families" title="pynbody.snapshot.SimSnap.families"><code class="xref py py-obj docutils literal notranslate"><span class="pre">families</span></code></a>()</p></td>
<td><p>Return the particle families which have representitives in this SimSnap.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.family_keys" title="pynbody.snapshot.SimSnap.family_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">family_keys</span></code></a>([fam])</p></td>
<td><p>Return list of arrays which are not accessible from this view, but can be accessed from family-specific sub-views.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.get" title="pynbody.snapshot.SimSnap.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(key[, alternative])</p></td>
<td><p>Standard python get method, returns self[key] if key in self else alternative</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.get_index_list" title="pynbody.snapshot.SimSnap.get_index_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_index_list</span></code></a>(relative_to[, of_particles])</p></td>
<td><p>Get a list specifying the index of the particles in this view relative to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.halos" title="pynbody.snapshot.SimSnap.halos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">halos</span></code></a>(*args, **kwargs)</p></td>
<td><p>Tries to instantiate a halo catalogue object for the given snapshot, using the first available method (as defined in the configuration files).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.has_family_key" title="pynbody.snapshot.SimSnap.has_family_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_family_key</span></code></a>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory) for at least one family</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.has_key" title="pynbody.snapshot.SimSnap.has_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_key</span></code></a>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.infer_original_units" title="pynbody.snapshot.SimSnap.infer_original_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_original_units</span></code></a>(dimensions)</p></td>
<td><p>Given a unit (or string) <cite>dimensions</cite>, returns a unit with the same physical dimensions which is in the unit schema of the current file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.intersect" title="pynbody.snapshot.SimSnap.intersect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersect</span></code></a>(other[, op])</p></td>
<td><p>Returns the set intersection of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.is_ancestor" title="pynbody.snapshot.SimSnap.is_ancestor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ancestor</span></code></a>(other)</p></td>
<td><p>Returns true if other is a subview of self</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.is_derived_array" title="pynbody.snapshot.SimSnap.is_derived_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_derived_array</span></code></a>(name[, fam])</p></td>
<td><p>Returns True if the array or family array of given name is auto-derived (and therefore read-only).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.is_descendant" title="pynbody.snapshot.SimSnap.is_descendant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_descendant</span></code></a>(other)</p></td>
<td><p>Returns true if self is a subview of other</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.items" title="pynbody.snapshot.SimSnap.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p>Returns a list of tuples describing the array names and their contents in memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.keys" title="pynbody.snapshot.SimSnap.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</p></td>
<td><p>Return the directly accessible array names (in memory)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.load_copy" title="pynbody.snapshot.SimSnap.load_copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code></a>()</p></td>
<td><p>Tries to load a copy of this snapshot, using partial loading to select only a subset of particles corresponding to a given SubSnap</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.loadable_keys" title="pynbody.snapshot.SimSnap.loadable_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loadable_keys</span></code></a>([fam])</p></td>
<td><p>Returns a list of arrays which can be lazy-loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.mean_by_mass" title="pynbody.snapshot.SimSnap.mean_by_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_by_mass</span></code></a>(name)</p></td>
<td><p>Calculate the mean by mass of the specified array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.original_units" title="pynbody.snapshot.SimSnap.original_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">original_units</span></code></a>()</p></td>
<td><p>Converts all arrays’units to be consistent with the units of the original file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.physical_units" title="pynbody.snapshot.SimSnap.physical_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">physical_units</span></code></a>([distance, velocity, mass, …])</p></td>
<td><p>Converts all array’s units to be consistent with the distance, velocity, mass basis units specified.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.rotate_x" title="pynbody.snapshot.SimSnap.rotate_x"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_x</span></code></a>(angle)</p></td>
<td><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.rotate_y" title="pynbody.snapshot.SimSnap.rotate_y"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_y</span></code></a>(angle)</p></td>
<td><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.rotate_z" title="pynbody.snapshot.SimSnap.rotate_z"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_z</span></code></a>(angle)</p></td>
<td><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.set_units_system" title="pynbody.snapshot.SimSnap.set_units_system"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_system</span></code></a>([velocity, distance, mass, …])</p></td>
<td><p>Set the unit system for the snapshot by specifying any or all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite> units.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.setdiff" title="pynbody.snapshot.SimSnap.setdiff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdiff</span></code></a>(other)</p></td>
<td><p>Returns the set difference of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(matrix)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.union" title="pynbody.snapshot.SimSnap.union"><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code></a>(other)</p></td>
<td><p>Returns the set union of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.unlink_array" title="pynbody.snapshot.SimSnap.unlink_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlink_array</span></code></a>(name)</p></td>
<td><p>If the named array is auto-derived, this destroys the link so that the array becomes editable but no longer auto-updates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.values" title="pynbody.snapshot.SimSnap.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a>()</p></td>
<td><p>Returns a list of the actual arrays in memory</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.wrap" title="pynbody.snapshot.SimSnap.wrap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code></a>([boxsize, convention])</p></td>
<td><p>Wraps the positions of the particles in the box to lie between [-boxsize/2, boxsize/2].</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code>([fmt, filename])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SimSnap.write_array" title="pynbody.snapshot.SimSnap.write_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_array</span></code></a>(array_name[, fam, overwrite])</p></td>
<td><p>Write out the array with the specified name.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>decorator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iteritems</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>iterkeys</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>itervalues</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>stable_derived_quantity</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.families">
<code class="sig-name descname">families</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.families"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.families" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the particle families which have representitives in this SimSnap.
The families are ordered by their appearance in the snapshot.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directly accessible array names (in memory)</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.has_key">
<code class="sig-name descname">has_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.has_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.has_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array name is accessible (in memory)</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the actual arrays in memory</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of tuples describing the array
names and their contents in memory</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">alternative</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard python get method, returns self[key] if
key in self else alternative</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.has_family_key">
<code class="sig-name descname">has_family_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.has_family_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.has_family_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array name is accessible (in memory) for at least one family</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.loadable_keys">
<code class="sig-name descname">loadable_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.loadable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.loadable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-loaded from
an auxiliary file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.derivable_keys">
<code class="sig-name descname">derivable_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.derivable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.derivable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-evaluated.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.all_keys">
<code class="sig-name descname">all_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.all_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.all_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all arrays that can be either lazy-evaluated
or lazy loaded from an auxiliary file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.family_keys">
<code class="sig-name descname">family_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.family_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.family_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of arrays which are not accessible from this
view, but can be accessed from family-specific sub-views.</p>
<p>If <em>fam</em> is not None, only those keys applying to the specific
family will be returned (equivalent to self.fam.keys()).</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.is_ancestor">
<code class="sig-name descname">is_ancestor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.is_ancestor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if other is a subview of self</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.is_descendant">
<code class="sig-name descname">is_descendant</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.is_descendant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_descendant" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is a subview of other</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.ancestor">
<em class="property">property </em><code class="sig-name descname">ancestor</code><a class="headerlink" href="#pynbody.snapshot.SimSnap.ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.get_index_list">
<code class="sig-name descname">get_index_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">relative_to</span></em>, <em class="sig-param"><span class="n">of_particles</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.get_index_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.get_index_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list specifying the index of the particles in this view relative
to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.intersect">
<code class="sig-name descname">intersect</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">op=&lt;function intersect1d&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.intersect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set intersection of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set union of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.setdiff">
<code class="sig-name descname">setdiff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.setdiff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.setdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set difference of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.conversion_context">
<code class="sig-name descname">conversion_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.conversion_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.conversion_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing a (scalefactor) and h
(Hubble constant in canonical units) for this snapshot, ready for
passing into unit conversion functions.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.set_units_system">
<code class="sig-name descname">set_units_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">velocity</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">distance</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mass</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">temperature</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.set_units_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.set_units_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the unit system for the snapshot by specifying any or
all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite>
units. The units can be given as strings or as pynbody <cite>Unit</cite>
objects.</p>
<p>If any of the units are not specified and a previous
<cite>file_units_system</cite> does not exist, the defaults are used.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.original_units">
<code class="sig-name descname">original_units</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.original_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.original_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all arrays’units to be consistent with the units of
the original file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.physical_units">
<code class="sig-name descname">physical_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span><span class="o">=</span><span class="default_value">'kpc'</span></em>, <em class="sig-param"><span class="n">velocity</span><span class="o">=</span><span class="default_value">'km s^-1'</span></em>, <em class="sig-param"><span class="n">mass</span><span class="o">=</span><span class="default_value">'Msol'</span></em>, <em class="sig-param"><span class="n">persistent</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.physical_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.physical_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all array’s units to be consistent with the
distance, velocity, mass basis units specified.</p>
<p>Base units can be specified using keywords.</p>
<p><strong>Optional Keywords</strong>:</p>
<blockquote>
<div><p><em>distance</em>: string (default = ‘kpc’)</p>
<p><em>velocity</em>: string (default = ‘km s^-1’)</p>
<p><em>mass</em>: string (default = ‘Msol’)</p>
<p><em>persistent</em>: boolean (default = True); apply units change to future lazy-loaded arrays if True</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.infer_original_units">
<code class="sig-name descname">infer_original_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimensions</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.infer_original_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.infer_original_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a unit (or string) <cite>dimensions</cite>, returns a unit with the same
physical dimensions which is in the unit schema of the current file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.halos">
<code class="sig-name descname">halos</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.halos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to instantiate a halo catalogue object for the given
snapshot, using the first available method (as defined in the
configuration files).</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.bridge">
<code class="sig-name descname">bridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.bridge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to construct a bridge function between this SimSnap
and another one.</p>
<p>This function calls <a class="reference internal" href="convenience.html#pynbody.bridge.bridge_factory" title="pynbody.bridge.bridge_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">pynbody.bridge.bridge_factory()</span></code></a>. For
more information see <span class="xref std std-ref">bridge-tutorial</span>, or the reference
documentation for <a class="reference internal" href="convenience.html#module-pynbody.bridge" title="pynbody.bridge"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pynbody.bridge</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.load_copy">
<code class="sig-name descname">load_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.load_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.load_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to load a copy of this snapshot, using partial loading to select
only a subset of particles corresponding to a given SubSnap</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.rotate_x">
<code class="sig-name descname">rotate_x</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.rotate_x"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.rotate_y">
<code class="sig-name descname">rotate_y</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.rotate_y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.rotate_z">
<code class="sig-name descname">rotate_z</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.rotate_z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">convention</span><span class="o">=</span><span class="default_value">'center'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the positions of the particles in the box to lie between
[-boxsize/2, boxsize/2].</p>
<p>If no boxsize is specified, self.properties[“boxsize”] is used.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.write_array">
<code class="sig-name descname">write_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array_name</span></em>, <em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.write_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.write_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out the array with the specified name.</p>
<p>Some of the functionality is available via the
<a class="reference internal" href="#pynbody.array.SimArray.write" title="pynbody.array.SimArray.write"><code class="xref py py-func docutils literal notranslate"><span class="pre">pynbody.array.SimArray.write()</span></code></a> method, which calls the
present function with appropriate arguments.</p>
<p><strong>Input</strong></p>
<p><em>array_name</em> - the name of the array to write</p>
<p><strong>Optional Keywords</strong></p>
<dl class="simple">
<dt><em>fam</em> (None) - Write out only one family; or provide a list to</dt><dd><p>write out a set of families.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.is_derived_array">
<code class="sig-name descname">is_derived_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.is_derived_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_derived_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array or family array of given name is
auto-derived (and therefore read-only).</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.unlink_array">
<code class="sig-name descname">unlink_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.unlink_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.unlink_array" title="Permalink to this definition">¶</a></dt>
<dd><p>If the named array is auto-derived, this destroys the link so that
the array becomes editable but no longer auto-updates.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SimSnap.mean_by_mass">
<code class="sig-name descname">mean_by_mass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SimSnap.mean_by_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.mean_by_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mean by mass of the specified array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.snapshot.SubSnap">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">SubSnap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">_slice</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent a sub-view of a SimSnap, initialized by specifying a
slice.  Arrays accessed through __getitem__ are automatically
sub-viewed using the given slice.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></dt><dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd>
<dt><strong>filename</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_keys</span></code>()</p></td>
<td><p>Returns a list of all arrays that can be either lazy-evaluated or lazy loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bridge</span></code>(other)</p></td>
<td><p>Tries to construct a bridge function between this SimSnap and another one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conversion_context</span></code>()</p></td>
<td><p>Return a dictionary containing a (scalefactor) and h (Hubble constant in canonical units) for this snapshot, ready for passing into unit conversion functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.derivable_keys" title="pynbody.snapshot.SubSnap.derivable_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivable_keys</span></code></a>()</p></td>
<td><p>Returns a list of arrays which can be lazy-evaluated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derived_quantity</span></code>(fn)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">families</span></code>()</p></td>
<td><p>Return the particle families which have representitives in this SimSnap.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.family_keys" title="pynbody.snapshot.SubSnap.family_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">family_keys</span></code></a>([fam])</p></td>
<td><p>Return list of arrays which are not accessible from this view, but can be accessed from family-specific sub-views.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(key[, alternative])</p></td>
<td><p>Standard python get method, returns self[key] if key in self else alternative</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.get_index_list" title="pynbody.snapshot.SubSnap.get_index_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_index_list</span></code></a>(relative_to[, of_particles])</p></td>
<td><p>Get a list specifying the index of the particles in this view relative to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">halos</span></code>(*args, **kwargs)</p></td>
<td><p>Tries to instantiate a halo catalogue object for the given snapshot, using the first available method (as defined in the configuration files).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_family_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory) for at least one family</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.infer_original_units" title="pynbody.snapshot.SubSnap.infer_original_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_original_units</span></code></a>(*args)</p></td>
<td><p>Return the units on disk for a quantity with the specified dimensions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersect</span></code>(other[, op])</p></td>
<td><p>Returns the set intersection of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ancestor</span></code>(other)</p></td>
<td><p>Returns true if other is a subview of self</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.is_derived_array" title="pynbody.snapshot.SubSnap.is_derived_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_derived_array</span></code></a>(v[, fam])</p></td>
<td><p>Returns True if the array or family array of given name is auto-derived (and therefore read-only).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_descendant</span></code>(other)</p></td>
<td><p>Returns true if self is a subview of other</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p>Returns a list of tuples describing the array names and their contents in memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.keys" title="pynbody.snapshot.SubSnap.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</p></td>
<td><p>Return the directly accessible array names (in memory)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code>()</p></td>
<td><p>Tries to load a copy of this snapshot, using partial loading to select only a subset of particles corresponding to a given SubSnap</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.loadable_keys" title="pynbody.snapshot.SubSnap.loadable_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loadable_keys</span></code></a>([fam])</p></td>
<td><p>Returns a list of arrays which can be lazy-loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_by_mass</span></code>(name)</p></td>
<td><p>Calculate the mean by mass of the specified array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">original_units</span></code>()</p></td>
<td><p>Converts all arrays’units to be consistent with the units of the original file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.physical_units" title="pynbody.snapshot.SubSnap.physical_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">physical_units</span></code></a>(*args, **kwargs)</p></td>
<td><p>Converts all array’s units to be consistent with the distance, velocity, mass basis units specified.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_x</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_y</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_z</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_system</span></code>([velocity, distance, mass, …])</p></td>
<td><p>Set the unit system for the snapshot by specifying any or all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite> units.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdiff</span></code>(other)</p></td>
<td><p>Returns the set difference of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(matrix)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other)</p></td>
<td><p>Returns the set union of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.unlink_array" title="pynbody.snapshot.SubSnap.unlink_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlink_array</span></code></a>(name)</p></td>
<td><p>If the named array is auto-derived, this destroys the link so that the array becomes editable but no longer auto-updates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p>Returns a list of the actual arrays in memory</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code>([boxsize, convention])</p></td>
<td><p>Wraps the positions of the particles in the box to lie between [-boxsize/2, boxsize/2].</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code>([fmt, filename])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.snapshot.SubSnap.write_array" title="pynbody.snapshot.SubSnap.write_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_array</span></code></a>(array_name[, fam])</p></td>
<td><p>Write out the array with the specified name.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>decorator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iteritems</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>iterkeys</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>itervalues</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>stable_derived_quantity</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directly accessible array names (in memory)</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.loadable_keys">
<code class="sig-name descname">loadable_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.loadable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.loadable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-loaded from
an auxiliary file.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.derivable_keys">
<code class="sig-name descname">derivable_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.derivable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.derivable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-evaluated.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.infer_original_units">
<code class="sig-name descname">infer_original_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.infer_original_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.infer_original_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the units on disk for a quantity with the specified dimensions</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.write_array">
<code class="sig-name descname">write_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array_name</span></em>, <em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.write_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.write_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out the array with the specified name.</p>
<p>Some of the functionality is available via the
<a class="reference internal" href="#pynbody.array.SimArray.write" title="pynbody.array.SimArray.write"><code class="xref py py-func docutils literal notranslate"><span class="pre">pynbody.array.SimArray.write()</span></code></a> method, which calls the
present function with appropriate arguments.</p>
<p><strong>Input</strong></p>
<p><em>array_name</em> - the name of the array to write</p>
<p><strong>Optional Keywords</strong></p>
<dl class="simple">
<dt><em>fam</em> (None) - Write out only one family; or provide a list to</dt><dd><p>write out a set of families.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.family_keys">
<code class="sig-name descname">family_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.family_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.family_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of arrays which are not accessible from this
view, but can be accessed from family-specific sub-views.</p>
<p>If <em>fam</em> is not None, only those keys applying to the specific
family will be returned (equivalent to self.fam.keys()).</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.physical_units">
<code class="sig-name descname">physical_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.physical_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.physical_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all array’s units to be consistent with the
distance, velocity, mass basis units specified.</p>
<p>Base units can be specified using keywords.</p>
<p><strong>Optional Keywords</strong>:</p>
<blockquote>
<div><p><em>distance</em>: string (default = ‘kpc’)</p>
<p><em>velocity</em>: string (default = ‘km s^-1’)</p>
<p><em>mass</em>: string (default = ‘Msol’)</p>
<p><em>persistent</em>: boolean (default = True); apply units change to future lazy-loaded arrays if True</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.is_derived_array">
<code class="sig-name descname">is_derived_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.is_derived_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.is_derived_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array or family array of given name is
auto-derived (and therefore read-only).</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.unlink_array">
<code class="sig-name descname">unlink_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.unlink_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.unlink_array" title="Permalink to this definition">¶</a></dt>
<dd><p>If the named array is auto-derived, this destroys the link so that
the array becomes editable but no longer auto-updates.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.SubSnap.get_index_list">
<code class="sig-name descname">get_index_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">relative_to</span></em>, <em class="sig-param"><span class="n">of_particles</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#SubSnap.get_index_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap.get_index_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list specifying the index of the particles in this view relative
to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.snapshot.IndexedSubSnap">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">IndexedSubSnap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">index_array</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">iord_array</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#IndexedSubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.IndexedSubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a subset of the simulation particles according
to an index array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base</strong><span class="classifier">SimSnap object</span></dt><dd><p>The base snapshot</p>
</dd>
<dt><strong>index_array</strong><span class="classifier">integer array or None</span></dt><dd><p>The indices of the elements that define the sub snapshot. Set to None to use iord-based instead.</p>
</dd>
<dt><strong>iord_array</strong><span class="classifier">integer array or None</span></dt><dd><p>The iord of the elements that define the sub snapshot. Set to None to use index-based instead.
This may be computationally expensive. See note below.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>index_array</cite> and <cite>iord_array</cite> arguments are mutually exclusive.
In the case of <cite>iord_array</cite>, an sorting operation is required that may take
a significant time and require O(N) memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></dt><dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd>
<dt><strong>filename</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_keys</span></code>()</p></td>
<td><p>Returns a list of all arrays that can be either lazy-evaluated or lazy loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bridge</span></code>(other)</p></td>
<td><p>Tries to construct a bridge function between this SimSnap and another one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conversion_context</span></code>()</p></td>
<td><p>Return a dictionary containing a (scalefactor) and h (Hubble constant in canonical units) for this snapshot, ready for passing into unit conversion functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivable_keys</span></code>()</p></td>
<td><p>Returns a list of arrays which can be lazy-evaluated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derived_quantity</span></code>(fn)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">families</span></code>()</p></td>
<td><p>Return the particle families which have representitives in this SimSnap.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">family_keys</span></code>([fam])</p></td>
<td><p>Return list of arrays which are not accessible from this view, but can be accessed from family-specific sub-views.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(key[, alternative])</p></td>
<td><p>Standard python get method, returns self[key] if key in self else alternative</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_index_list</span></code>(relative_to[, of_particles])</p></td>
<td><p>Get a list specifying the index of the particles in this view relative to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">halos</span></code>(*args, **kwargs)</p></td>
<td><p>Tries to instantiate a halo catalogue object for the given snapshot, using the first available method (as defined in the configuration files).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_family_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory) for at least one family</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_original_units</span></code>(*args)</p></td>
<td><p>Return the units on disk for a quantity with the specified dimensions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersect</span></code>(other[, op])</p></td>
<td><p>Returns the set intersection of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ancestor</span></code>(other)</p></td>
<td><p>Returns true if other is a subview of self</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_derived_array</span></code>(v[, fam])</p></td>
<td><p>Returns True if the array or family array of given name is auto-derived (and therefore read-only).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_descendant</span></code>(other)</p></td>
<td><p>Returns true if self is a subview of other</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p>Returns a list of tuples describing the array names and their contents in memory</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</p></td>
<td><p>Return the directly accessible array names (in memory)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code>()</p></td>
<td><p>Tries to load a copy of this snapshot, using partial loading to select only a subset of particles corresponding to a given SubSnap</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loadable_keys</span></code>([fam])</p></td>
<td><p>Returns a list of arrays which can be lazy-loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_by_mass</span></code>(name)</p></td>
<td><p>Calculate the mean by mass of the specified array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">original_units</span></code>()</p></td>
<td><p>Converts all arrays’units to be consistent with the units of the original file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">physical_units</span></code>(*args, **kwargs)</p></td>
<td><p>Converts all array’s units to be consistent with the distance, velocity, mass basis units specified.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_x</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_y</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_z</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_system</span></code>([velocity, distance, mass, …])</p></td>
<td><p>Set the unit system for the snapshot by specifying any or all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite> units.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdiff</span></code>(other)</p></td>
<td><p>Returns the set difference of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(matrix)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other)</p></td>
<td><p>Returns the set union of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlink_array</span></code>(name)</p></td>
<td><p>If the named array is auto-derived, this destroys the link so that the array becomes editable but no longer auto-updates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p>Returns a list of the actual arrays in memory</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code>([boxsize, convention])</p></td>
<td><p>Wraps the positions of the particles in the box to lie between [-boxsize/2, boxsize/2].</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code>([fmt, filename])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_array</span></code>(array_name[, fam])</p></td>
<td><p>Write out the array with the specified name.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>decorator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iteritems</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>iterkeys</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>itervalues</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>stable_derived_quantity</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="pynbody.snapshot.FamilySubSnap">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">FamilySubSnap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">fam</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#FamilySubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.FamilySubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a one-family portion of a parent snap object</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ancestor</span></code></dt><dd><p>The original SimSnap from which this view is derived (potentially self)</p>
</dd>
<dt><strong>filename</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_keys</span></code>()</p></td>
<td><p>Returns a list of all arrays that can be either lazy-evaluated or lazy loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bridge</span></code>(other)</p></td>
<td><p>Tries to construct a bridge function between this SimSnap and another one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conversion_context</span></code>()</p></td>
<td><p>Return a dictionary containing a (scalefactor) and h (Hubble constant in canonical units) for this snapshot, ready for passing into unit conversion functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivable_keys</span></code>()</p></td>
<td><p>Returns a list of arrays which can be lazy-evaluated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">derived_quantity</span></code>(fn)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">families</span></code>()</p></td>
<td><p>Return the particle families which have representitives in this SimSnap.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.FamilySubSnap.family_keys" title="pynbody.snapshot.FamilySubSnap.family_keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">family_keys</span></code></a>([fam])</p></td>
<td><p>Return list of arrays which are not accessible from this view, but can be accessed from family-specific sub-views.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(key[, alternative])</p></td>
<td><p>Standard python get method, returns self[key] if key in self else alternative</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_index_list</span></code>(relative_to[, of_particles])</p></td>
<td><p>Get a list specifying the index of the particles in this view relative to the ancestor <em>relative_to</em>, such that relative_to[get_index_list(relative_to)]==self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">halos</span></code>(*args, **kwargs)</p></td>
<td><p>Tries to instantiate a halo catalogue object for the given snapshot, using the first available method (as defined in the configuration files).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_family_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory) for at least one family</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_key</span></code>(name)</p></td>
<td><p>Returns True if the array name is accessible (in memory)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">infer_original_units</span></code>(*args)</p></td>
<td><p>Return the units on disk for a quantity with the specified dimensions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersect</span></code>(other[, op])</p></td>
<td><p>Returns the set intersection of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ancestor</span></code>(other)</p></td>
<td><p>Returns true if other is a subview of self</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_derived_array</span></code>(v[, fam])</p></td>
<td><p>Returns True if the array or family array of given name is auto-derived (and therefore read-only).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_descendant</span></code>(other)</p></td>
<td><p>Returns true if self is a subview of other</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p>Returns a list of tuples describing the array names and their contents in memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.snapshot.FamilySubSnap.keys" title="pynbody.snapshot.FamilySubSnap.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</p></td>
<td><p>Return the directly accessible array names (in memory)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_copy</span></code>()</p></td>
<td><p>Tries to load a copy of this snapshot, using partial loading to select only a subset of particles corresponding to a given SubSnap</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loadable_keys</span></code>([fam])</p></td>
<td><p>Returns a list of arrays which can be lazy-loaded from an auxiliary file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_by_mass</span></code>(name)</p></td>
<td><p>Calculate the mean by mass of the specified array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">original_units</span></code>()</p></td>
<td><p>Converts all arrays’units to be consistent with the units of the original file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">physical_units</span></code>(*args, **kwargs)</p></td>
<td><p>Converts all array’s units to be consistent with the distance, velocity, mass basis units specified.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_x</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current x-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_y</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current y-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_z</span></code>(angle)</p></td>
<td><p>Rotates the snapshot about the current z-axis by ‘angle’ degrees.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units_system</span></code>([velocity, distance, mass, …])</p></td>
<td><p>Set the unit system for the snapshot by specifying any or all of <cite>velocity</cite>, <cite>distance</cite>, <cite>mass</cite> and <cite>temperature</cite> units.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdiff</span></code>(other)</p></td>
<td><p>Returns the set difference of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(matrix)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other)</p></td>
<td><p>Returns the set union of this simulation view with another view of the same simulation</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlink_array</span></code>(name)</p></td>
<td><p>If the named array is auto-derived, this destroys the link so that the array becomes editable but no longer auto-updates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p>Returns a list of the actual arrays in memory</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code>([boxsize, convention])</p></td>
<td><p>Wraps the positions of the particles in the box to lie between [-boxsize/2, boxsize/2].</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code>([fmt, filename])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_array</span></code>(array_name[, fam])</p></td>
<td><p>Write out the array with the specified name.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>decorator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>iteritems</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>iterkeys</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>itervalues</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>stable_derived_quantity</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.snapshot.FamilySubSnap.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#FamilySubSnap.keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.FamilySubSnap.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directly accessible array names (in memory)</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.snapshot.FamilySubSnap.family_keys">
<code class="sig-name descname">family_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fam</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#FamilySubSnap.family_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.FamilySubSnap.family_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of arrays which are not accessible from this
view, but can be accessed from family-specific sub-views.</p>
<p>If <em>fam</em> is not None, only those keys applying to the specific
family will be returned (equivalent to self.fam.keys()).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynbody.snapshot.load">
<code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a file using the appropriate class, returning a SimSnap
instance.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.snapshot.new">
<code class="sig-prename descclassname">pynbody.snapshot.</code><code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_particles</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">families</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/snapshot.html#new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a blank SimSnap, with the specified number of particles.</p>
<p>Position, velocity and mass arrays are created and filled
with zeros.</p>
<p>By default all particles are taken to be dark matter.
To specify otherwise, pass in keyword arguments specifying
the number of particles for each family, e.g.</p>
<p>f = new(dm=50, star=25, gas=25)</p>
<p>The order in which the different families appear in the snapshot
is unspecified unless you add an ‘order’ argument:</p>
<p>f = new(dm=50, star=25, gas=25, order=’star,gas,dm’)</p>
<p>guarantees the stars, then gas, then dark matter particles appear
in sequence.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.units"></span><div class="section" id="units">
<h2>units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h2>
<p>The pynbody units module consists of a set of classes for tracking units.</p>
<p>It relates closely to the <a class="reference internal" href="#module-pynbody.array" title="pynbody.array"><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> module, which defines
an extension to numpy arrays which carries unit information.</p>
<div class="section" id="making-units">
<h3>Making units<a class="headerlink" href="#making-units" title="Permalink to this headline">¶</a></h3>
<p>Units are generated and used at various points through the pynbody
framework. Quite often the functions where users interact with units
simply accept strings.</p>
<p>You can also make units yourself in two ways. Either you can create a string, and
instantiate a Unit like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">units</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;Msol kpc**-3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">units</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;2.1e12 m_p cm**-2/3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or you can do it within python, using the named Unit objects</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">units</span><span class="o">.</span><span class="n">Msol</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">kpc</span><span class="o">**-</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2.1e12</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">m_p</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>In the last example, either a tuple describing a fraction or a
Fraction instance (from the standard python module fractions) is
acceptable.</p>
</div>
<div class="section" id="getting-conversion-ratios">
<h3>Getting conversion ratios<a class="headerlink" href="#getting-conversion-ratios" title="Permalink to this headline">¶</a></h3>
<p>To convert one unit to another, use the <code class="docutils literal notranslate"><span class="pre">ratio</span></code> member function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">units</span><span class="o">.</span><span class="n">Msol</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">kg</span><span class="p">)</span>
<span class="go">1.99e30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">Msol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">kpc</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">m_p</span><span class="o">/</span><span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4.04e-8</span>
</pre></div>
</div>
<p>If the units cannot be converted, a UnitsException is raised:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">units</span><span class="o">.</span><span class="n">Msol</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">kpc</span><span class="p">)</span>
<span class="go">UnitsException</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-numerical-values">
<h3>Specifying numerical values<a class="headerlink" href="#specifying-numerical-values" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it’s necessary to specify a numerical value in the course
of a conversion. For instance, consider a comoving distance; this
can be specified in pynbody units as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comoving_kpc</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">kpc</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">a</span>
</pre></div>
</div>
<p>where units.a represents the scalefactor. We can attempt to convert
this to a physical distance as follows</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comoving_kpc</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">kpc</span><span class="p">)</span>
</pre></div>
</div>
<p>but this fails, throwing a UnitsException. On the other hand we
can specify a value for the scalefactor when we request the conversion</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comoving_kpc</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">kpc</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>and the conversion completes with the expected result. The units
module also defines units.h for the dimensionless hubble constant,
which can be used similarly. <em>By default, all conversions happening
within a specific simulation context should pass in values for
a and h as a matter of routine.</em></p>
<p>Any IrreducibleUnit (see below) can have a value specified in this way,
but a and h are envisaged to be the most useful applications.</p>
</div>
<div class="section" id="defining-new-base-units">
<h3>Defining new base units<a class="headerlink" href="#defining-new-base-units" title="Permalink to this headline">¶</a></h3>
<p>The units module is fully extensible: you can define and name your own
units which then integrate with all the standard functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">litre</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">NamedUnit</span><span class="p">(</span><span class="s2">&quot;litre&quot;</span><span class="p">,</span><span class="mf">0.001</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">gallon</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">NamedUnit</span><span class="p">(</span><span class="s2">&quot;gallon&quot;</span><span class="p">,</span><span class="mf">0.004546</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">gallon</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">litre</span><span class="p">)</span> <span class="c1"># 4.546</span>
<span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">pc</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">litre</span><span class="p">)</span> <span class="c1"># 2.94e52</span>
</pre></div>
</div>
<p>You can even define completely new dimensions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">IrreducibleUnit</span><span class="p">(</span><span class="s2">&quot;V&quot;</span><span class="p">)</span> <span class="c1"># define a volt</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">NamedUnit</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">V</span><span class="p">)</span> <span class="c1"># define a coulomb</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">NamedUnit</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="mf">1.60217646e-19</span><span class="o">*</span><span class="n">C</span><span class="p">)</span> <span class="c1"># elementary charge</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">NamedUnit</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">/</span><span class="n">V</span><span class="p">)</span> <span class="c1"># Farad</span>
<span class="n">epsilon0</span> <span class="o">=</span> <span class="mf">8.85418e-12</span> <span class="o">*</span><span class="n">F</span><span class="o">/</span><span class="n">units</span><span class="o">.</span><span class="n">m</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
<span class="go">1.000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">epsilon0</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">)</span>
<span class="go">2.31e-28</span>
</pre></div>
</div>
<dl class="py exception">
<dt id="pynbody.units.UnitsException">
<em class="property">exception </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">UnitsException</code><a class="reference internal" href="../_modules/pynbody/units.html#UnitsException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitsException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="pynbody.units.UnitBase">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">UnitBase</code><a class="reference internal" href="../_modules/pynbody/units.html#UnitBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for units. To instantiate a unit, call the <a class="reference internal" href="#pynbody.units.Unit" title="pynbody.units.Unit"><code class="xref py py-func docutils literal notranslate"><span class="pre">pynbody.units.Unit()</span></code></a>
factory function.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.UnitBase.in_units" title="pynbody.units.UnitBase.in_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code></a>(*a, **kw)</p></td>
<td><p>Alias for ratio</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.UnitBase.irrep" title="pynbody.units.UnitBase.irrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep</span></code></a>()</p></td>
<td><p>Return a unit equivalent to this one (may be identical) but expressed in terms of the currently defined IrreducibleUnit instances.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.UnitBase.ratio" title="pynbody.units.UnitBase.ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratio</span></code></a>(other, **substitutions)</p></td>
<td><p>Get the conversion ratio between this Unit and another specified unit.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>is_dimensionless</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>simplify</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.units.UnitBase.ratio">
<code class="sig-name descname">ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">substitutions</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#UnitBase.ratio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the conversion ratio between this Unit and another
specified unit.</p>
<p>Keyword arguments, if specified, give numerical substitutions
for the named unit. This is most useful for specifying values
for cosmological quantities like ‘a’ and ‘h’, but can also
be used for any IrreducibleUnit.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc a&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;kpc&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">250.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;Msol&quot;</span><span class="p">)</span>
<span class="go">UnitsException: not convertible</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;Msol&quot;</span><span class="p">,</span> <span class="n">kg</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mf">50.0</span><span class="p">)</span>
<span class="go">3.1028701506345152e-08</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.UnitBase.in_units">
<code class="sig-name descname">in_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">a</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#UnitBase.in_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.in_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for ratio</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.UnitBase.irrep">
<code class="sig-name descname">irrep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#UnitBase.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unit equivalent to this one (may be identical) but
expressed in terms of the currently defined IrreducibleUnit
instances.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.units.NoUnit">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">NoUnit</code><a class="reference internal" href="../_modules/pynbody/units.html#NoUnit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.NoUnit" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code>(*a, **kw)</p></td>
<td><p>Alias for ratio</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.NoUnit.irrep" title="pynbody.units.NoUnit.irrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep</span></code></a>()</p></td>
<td><p>Return a unit equivalent to this one (may be identical) but expressed in terms of the currently defined IrreducibleUnit instances.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.NoUnit.ratio" title="pynbody.units.NoUnit.ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratio</span></code></a>(other, **substitutions)</p></td>
<td><p>Get the conversion ratio between this Unit and another specified unit.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>dimensional_project</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>is_dimensionless</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>latex</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>simplify</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.units.NoUnit.ratio">
<code class="sig-name descname">ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">substitutions</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#NoUnit.ratio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.NoUnit.ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the conversion ratio between this Unit and another
specified unit.</p>
<p>Keyword arguments, if specified, give numerical substitutions
for the named unit. This is most useful for specifying values
for cosmological quantities like ‘a’ and ‘h’, but can also
be used for any IrreducibleUnit.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc a&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;kpc&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">250.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;Msol&quot;</span><span class="p">)</span>
<span class="go">UnitsException: not convertible</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1 Mpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;Msol&quot;</span><span class="p">,</span> <span class="n">kg</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mf">50.0</span><span class="p">)</span>
<span class="go">3.1028701506345152e-08</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.NoUnit.irrep">
<code class="sig-name descname">irrep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#NoUnit.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.NoUnit.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unit equivalent to this one (may be identical) but
expressed in terms of the currently defined IrreducibleUnit
instances.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.units.IrreducibleUnit">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">IrreducibleUnit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">st</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#IrreducibleUnit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.IrreducibleUnit" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code>(*a, **kw)</p></td>
<td><p>Alias for ratio</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.IrreducibleUnit.irrep" title="pynbody.units.IrreducibleUnit.irrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep</span></code></a>()</p></td>
<td><p>Return a unit equivalent to this one (may be identical) but expressed in terms of the currently defined IrreducibleUnit instances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratio</span></code>(other, **substitutions)</p></td>
<td><p>Get the conversion ratio between this Unit and another specified unit.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>is_dimensionless</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>latex</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>simplify</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.units.IrreducibleUnit.irrep">
<code class="sig-name descname">irrep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#IrreducibleUnit.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.IrreducibleUnit.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unit equivalent to this one (may be identical) but
expressed in terms of the currently defined IrreducibleUnit
instances.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.units.NamedUnit">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">NamedUnit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">st</span></em>, <em class="sig-param"><span class="n">represents</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#NamedUnit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.NamedUnit" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code>(*a, **kw)</p></td>
<td><p>Alias for ratio</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.NamedUnit.irrep" title="pynbody.units.NamedUnit.irrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep</span></code></a>()</p></td>
<td><p>Return a unit equivalent to this one (may be identical) but expressed in terms of the currently defined IrreducibleUnit instances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratio</span></code>(other, **substitutions)</p></td>
<td><p>Get the conversion ratio between this Unit and another specified unit.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>is_dimensionless</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>latex</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>simplify</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.units.NamedUnit.irrep">
<code class="sig-name descname">irrep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#NamedUnit.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.NamedUnit.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unit equivalent to this one (may be identical) but
expressed in terms of the currently defined IrreducibleUnit
instances.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pynbody.units.CompositeUnit">
<em class="property">class </em><code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">CompositeUnit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scale</span></em>, <em class="sig-param"><span class="n">bases</span></em>, <em class="sig-param"><span class="n">powers</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.copy" title="pynbody.units.CompositeUnit.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Create a copy which is ‘shallow’ in the sense that it references exactly the same underlying base units, but where the list of those units can be manipulated separately.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.dimensional_project" title="pynbody.units.CompositeUnit.dimensional_project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimensional_project</span></code></a>(basis_units)</p></td>
<td><p>Work out how to express the dimensions of this unit relative to the specified list of basis units.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.dimensionless_constant" title="pynbody.units.CompositeUnit.dimensionless_constant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimensionless_constant</span></code></a>(**substitutions)</p></td>
<td><p>If this unit is dimensionless, return its scalar quantity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_units</span></code>(*a, **kw)</p></td>
<td><p>Alias for ratio</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.irrep" title="pynbody.units.CompositeUnit.irrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep</span></code></a>()</p></td>
<td><p>Return a new unit which represents this unit expressed solely in terms of IrreducibleUnit bases.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.is_dimensionless" title="pynbody.units.CompositeUnit.is_dimensionless"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_dimensionless</span></code></a>()</p></td>
<td><p>Returns true if this unit actually translates into a scalar quantity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pynbody.units.CompositeUnit.latex" title="pynbody.units.CompositeUnit.latex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">latex</span></code></a>()</p></td>
<td><p>Returns a LaTeX representation of this unit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ratio</span></code>(other, **substitutions)</p></td>
<td><p>Get the conversion ratio between this Unit and another specified unit.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>simplify</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="pynbody.units.CompositeUnit.latex">
<code class="sig-name descname">latex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.latex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.latex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a LaTeX representation of this unit.</p>
<p>Prefactors are converted into exponent notation. Named units by default
are represented by the string ‘mathrm{unit_name}’, although this can
be overriden in the pynbody configuration files or by setting
unit_name._latex.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.CompositeUnit.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy which is ‘shallow’ in the sense that it
references exactly the same underlying base units, but where
the list of those units can be manipulated separately.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.CompositeUnit.irrep">
<code class="sig-name descname">irrep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new unit which represents this unit expressed
solely in terms of IrreducibleUnit bases.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.CompositeUnit.is_dimensionless">
<code class="sig-name descname">is_dimensionless</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.is_dimensionless"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.is_dimensionless" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this unit actually translates into a scalar
quantity.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.CompositeUnit.dimensionless_constant">
<code class="sig-name descname">dimensionless_constant</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">substitutions</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.dimensionless_constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.dimensionless_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>If this unit is dimensionless, return its scalar quantity.</p>
<p>Direct use of this function is not recommended. It is generally
better to use the ratio function instead.</p>
<p>Provide keyword arguments to set values for named IrreducibleUnits –
see the ratio function for more information.</p>
</dd></dl>

<dl class="py method">
<dt id="pynbody.units.CompositeUnit.dimensional_project">
<code class="sig-name descname">dimensional_project</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis_units</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#CompositeUnit.dimensional_project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.CompositeUnit.dimensional_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Work out how to express the dimensions of this unit relative to the
specified list of basis units.</p>
<p>This is used by the framework when making inferences about sensible units to
use in various situations.</p>
<p>For example, you can represent a length as an energy divided by a force:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;23 kpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensional_project</span><span class="p">([</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">])</span>
<span class="go">array([1, -1], dtype=object)</span>
</pre></div>
</div>
<p>However it’s not possible to represent a length by energy alone:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;23 kpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensional_project</span><span class="p">([</span><span class="s2">&quot;J&quot;</span><span class="p">])</span>
<span class="go">UnitsException: Basis units do not span dimensions of specified unit</span>
</pre></div>
</div>
<p>This function also doesn’t know what to do if the result is ambiguous:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;23 kpc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensional_project</span><span class="p">([</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;kpc&quot;</span><span class="p">])</span>
<span class="go">UnitsException: Basis units are not linearly independent</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pynbody.units.Unit">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">Unit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#Unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Class factory for units. Given a string s, creates
a Unit object.</p>
<dl class="simple">
<dt>The string format is:</dt><dd><p>[&lt;scale&gt;] [&lt;unit_name&gt;][<a href="#id1"><span class="problematic" id="id2">**</span></a>&lt;rational_power&gt;] [[&lt;unit_name&gt;] … ]</p>
</dd>
</dl>
<p>for example:</p>
<blockquote>
<div><p>“1.e30 kg”</p>
<p>“kpc**2”</p>
<p>“26.2 m s**-1”</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="pynbody.units.takes_arg_in_units">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">takes_arg_in_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">orig_kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#takes_arg_in_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.takes_arg_in_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a decorator to create a function which auto-converts input
to given units.</p>
<p><strong>Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@takes_arg_in_units</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Msol&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;kpc&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;blob&quot;</span><span class="p">,</span> <span class="s2">&quot;erg&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">blob</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span> <span class="p">:</span>
   <span class="nb">print</span> <span class="s2">&quot;Arg 2 is&quot;</span><span class="p">,</span><span class="n">arg2</span><span class="p">,</span><span class="s2">&quot;Msol&quot;</span>
   <span class="nb">print</span> <span class="s2">&quot;Arg 1 is&quot;</span><span class="p">,</span><span class="n">arg1</span><span class="p">,</span><span class="s2">&quot;kpc&quot;</span>
   <span class="nb">print</span> <span class="s2">&quot;blob is&quot;</span><span class="p">,</span><span class="n">blob</span><span class="p">,</span><span class="s2">&quot;ergs&quot;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">My_function</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="s2">&quot;1.e30 kg&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="n">blob</span><span class="o">=</span><span class="s2">&quot;12 J&quot;</span><span class="p">)</span>
<span class="go">Input 3 is 0.5 Msol</span>
<span class="go">Input 2 is 23 kpc</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pynbody.units.has_unit">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">has_unit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#has_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.has_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the specified object has a meaningful units attribute</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.units.has_units">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">has_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pynbody.units.has_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the specified object has a meaningful units attribute</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.units.is_unit">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">is_unit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#is_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.is_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the specified object represents a unit</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.units.is_unit_like">
<code class="sig-prename descclassname">pynbody.units.</code><code class="sig-name descname">is_unit_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/units.html#is_unit_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.is_unit_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the specified object is itself a unit or
otherwise exposes unit information</p>
</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.util"></span><div class="section" id="util">
<h2>util<a class="headerlink" href="#util" title="Permalink to this headline">¶</a></h2>
<p>Various utility routines used internally by pynbody.</p>
<dl class="py function">
<dt id="pynbody.util.open_">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">open_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#open_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.open_" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file, determining from the filename whether to use
gzip decompression</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.open_with_size">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">open_with_size</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#open_with_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.open_with_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file for reading, returning also the (decompressed)
file size</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.eps_as_simarray">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">eps_as_simarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">eps</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#eps_as_simarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.eps_as_simarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert th given eps to a SimArray with units of f[‘pos’] and dtype of f[‘mass’]</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.get_eps">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">get_eps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#get_eps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.get_eps" title="Permalink to this definition">¶</a></dt>
<dd><p>The gravitational softening length is determined from (in order of
preference):
1. the array f[‘eps’]
2. f.properties[‘eps’] (scalar or unit)</p>
<p>Return a SimArray with correct units and dtype (same dtype as ‘mass’ array)</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.intersect_slices">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">intersect_slices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em>, <em class="sig-param"><span class="n">array_length</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#intersect_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.intersect_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two python slices s1 and s2, return a new slice which
will extract the data of an array d which is in both d[s1] and
d[s2].</p>
<p>Note that it may not be possible to do this without information on
the length of the array referred to, hence all slices with
end-relative indexes are first converted into begin-relative
indexes. This means that the slice returned may be specific to
the length specified.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.relative_slice">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">relative_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s_relative_to</span></em>, <em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#relative_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.relative_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a slice s, return a slice s_prime with the property that
array[s_relative_to][s_prime] == array[s]. Clearly this will
not be possible for arbitrarily chosen s_relative_to and s, but
it should be possible for s=intersect_slices(s_relative_to, s_any)
which is the use case envisioned here (and used by SubSim).
This code currently does not work with end-relative (i.e. negative)
start or stop positions.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.chained_slice">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">chained_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#chained_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.chained_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a slice s3 with the property that
ar[s1][s2] == ar[s3]</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.index_before_slice">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">index_before_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#index_before_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.index_before_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an index array new_index with the property that, for a
slice s (start, stop and step all positive), ar[s][index] ==
ar[new_index].</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.concatenate_indexing">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">concatenate_indexing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i1</span></em>, <em class="sig-param"><span class="n">i2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#concatenate_indexing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.concatenate_indexing" title="Permalink to this definition">¶</a></dt>
<dd><p>Given either a numpy array or slice for both i1 and i2,
return either a numpy array or slice i3 with the property that</p>
<p>ar[i3] == ar[i1][i2].</p>
<p>As a convenience, if i2 is None, i1 is returned</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.indexing_length">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">indexing_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sl_or_ar</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#indexing_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.indexing_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Given either an array or slice, return len(ar[sl_or_ar]) for any
array ar which is large enough that the slice does not overrun it.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.arrays_are_same">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">arrays_are_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#arrays_are_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.arrays_are_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if a1 and a2 are numpy views pointing to the exact
same underlying data; False otherwise.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.set_array_if_not_same">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">set_array_if_not_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_store</span></em>, <em class="sig-param"><span class="n">a_in</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#set_array_if_not_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.set_array_if_not_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine checks whether a_store and a_in ultimately point to the
same buffer; if not, the contents of a_in are copied into a_store.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.index_of_first">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">index_of_first</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">find</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#index_of_first"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.index_of_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element in array
which satisfies array[index]&gt;=find. The array must
be sorted in ascending order.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.equipartition">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">equipartition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ar</span></em>, <em class="sig-param"><span class="n">nbins</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#equipartition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.equipartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array ar, return nbins+1 monotonically increasing bin
edges such that the number of items in each bin is approximately
equal.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.bisect">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">bisect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">niter_max</span><span class="o">=</span><span class="default_value">200</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#bisect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the value x such that f(x)=0 for a monotonically increasing
function f, using a binary search.</p>
<p>The search stops when either the bounding domain is smaller than
epsilon (by default 10^-7 times the original region) OR a value
f(x) is found such that <a href="#id3"><span class="problematic" id="id4">|</span></a>f(x)|&lt;eta (by default eta=0, so this
criterion is never satisfied).</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.gauss_jordan">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">gauss_jordan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">out</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#gauss_jordan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.gauss_jordan" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple Gauss-Jordan matrix inverter. This is provided so that
matrices of fractions can be inverted (numpy linalg converts
everything to floats first.)</p>
<p>Don’t use on large matrices – it’s slow!</p>
<p>Based on public domain code by Jarno Elonen.</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.rational_matrix_inv">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">rational_matrix_inv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#rational_matrix_inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.rational_matrix_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple replacement for numpy linalg matrix inverse
which handles fractions exactly. Not suitable for large
matrices!</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.random_rotation_matrix">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">random_rotation_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#random_rotation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.random_rotation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random rotation matrix (Haar measure for 3x3 case), using
fast algorithm from Graphics Gems III</p>
<p>(<a class="reference external" href="http://tog.acm.org/resources/GraphicsGems/gemsiii/rand_rotation.c">http://tog.acm.org/resources/GraphicsGems/gemsiii/rand_rotation.c</a>)</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.cutgz">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">cutgz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#cutgz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.cutgz" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the .gz ending off a string</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.gamma_inc">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">gamma_inc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">3e-07</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#gamma_inc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.gamma_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete gamma function accepting complex z, based on algorithm
given in numerical recipes (3rd ed)</p>
</dd></dl>

<dl class="py function">
<dt id="pynbody.util.threadsafe_inline">
<code class="sig-prename descclassname">pynbody.util.</code><code class="sig-name descname">threadsafe_inline</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynbody/util.html#threadsafe_inline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.threadsafe_inline" title="Permalink to this definition">¶</a></dt>
<dd><p>When scipy.weave.inline is called, it may trigger a compile. We
only want one compilation to be going on at once, otherwise nasty
race conditions arise. This function wraps scipy.weave.inline to
be thread-safe.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorials.html">Tutorials &amp; walkthroughs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Pynbody reference documentation</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Pynbody reference documentation</a></li>
      <li>Next: <a href="convenience.html" title="next chapter">Generic Convenience Modules</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2011-20, pynbody team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/reference/essentials.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>